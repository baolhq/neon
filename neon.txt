This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-06T09:37:41.201Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/workflows/publish.yml
.gitignore
build.toml
CHANGELOG.md
conf.lua
lib/anim8.lua
lib/moonshine/boxblur.lua
lib/moonshine/chromasep.lua
lib/moonshine/colorgradesimple.lua
lib/moonshine/crt.lua
lib/moonshine/desaturate.lua
lib/moonshine/dmg.lua
lib/moonshine/fastgaussianblur.lua
lib/moonshine/filmgrain.lua
lib/moonshine/fog.lua
lib/moonshine/gaussianblur.lua
lib/moonshine/glow.lua
lib/moonshine/godsray.lua
lib/moonshine/init.lua
lib/moonshine/pixelate.lua
lib/moonshine/posterize.lua
lib/moonshine/README.md
lib/moonshine/scanlines.lua
lib/moonshine/sketch.lua
lib/moonshine/vignette.lua
lib/tween.lua
lib/vector.lua
LICENSE.md
main.lua
README.md
src/globals/colors.lua
src/globals/consts.lua
src/globals/res.lua
src/managers/scene_manager.lua
src/models/enemy.lua
src/models/orb.lua
src/models/player.lua
src/scenes/lboard_scene.lua
src/scenes/main_scene.lua
src/scenes/settings_scene.lua
src/scenes/title_scene.lua
src/utils/collider.lua
src/utils/drawer.lua
src/utils/file.lua
src/utils/input.lua

================================================================
Repository Files
================================================================

================
File: .github/workflows/publish.yml
================
name: Publish

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip3 install setuptools
          pip3 install makelove

      - name: Build
        run: makelove --config build.toml

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: packages
          path: bin/

================
File: .gitignore
================
# Ignore build directory
bin/

# Ignore environment variables
**/*.env

# Ignore other IDE settings
.vs/
.idea/

================
File: build.toml
================
name = "NE√ñN"
default_targets = ["win64", "macos"]
build_directory = "bin"
love_files = ["+*", "-*/.*", "-bin/**"]

================
File: CHANGELOG.md
================
# Changelog

## 0.0.6

Newton appear and says:

- **Add gravity to the game**
- Longer airtime while holding jump button
- Add enemy dead animation
- Add score saving system

## 0.0.5

First major refactoring, lots of changes here

- **Change to horizontal scrolling instead of vertical**
- Rename `obstacle` to `enemy` to fit the sprite
- Add recommended VSCode extensions
- Update VSCode build for automatic clean
- Update input keybindings
- Use `love.graphics.getWidth()` to prepare for screen resizing

## 0.0.4

Revamped jumping logics, add visual guide, and catching some bugs üêõ

- Update jumping control to feel more "natural"
- Add animated scene transition
- Add pseudo random obstacle generator
- Add enemy animation
- Minor bugs caught

## 0.0.3

Just discovered moonshine, it's free real estate!

- Add moonshine for game shaders
- Refactor `accept` to be both `Space` and `Enter`
- Fix player flipping animation to be mid-jump

## 0.0.2

Some real juicy stuff here, check this out!

- Add animations for the player
- Add jumping logic for the player
- Add moving obstacle along the way
- Add glitching shader for title üî•

## 0.0.1

Not so much going on, just bringin' some stuff from my old project over.

- Add title, main and settings screen
- Add screen manager for easier switching
- Add cross-plarform build support
- Add many utility functions
- Add global constants for for easier management
- Some placeholder audio and images that I'll change later

================
File: conf.lua
================
local consts = require("src.globals.consts")

-- Setup initial stuff
function love.conf(t)
    t.window.width = consts.WINDOW_W
    t.window.height = consts.WINDOW_H
    t.window.msaa = 4
end

================
File: lib/anim8.lua
================
local anim8 = {
    _VERSION     = 'anim8 v2.3.1',
    _DESCRIPTION = 'An animation library for L√ñVE',
    _URL         = 'https://github.com/kikito/anim8',
    _LICENSE     = [[
      MIT LICENSE

      Copyright (c) 2011 Enrique Garc√≠a Cota

      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:

      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
    if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
    if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
    if value ~= math.floor(value) then error(("%s should be an integer, was %f"):format(name, value)) end
end

local function createFrame(self, x, y)
    local fw, fh = self.frameWidth, self.frameHeight
    return love.graphics.newQuad(
        self.left + (x - 1) * fw + x * self.border,
        self.top + (y - 1) * fh + y * self.border,
        fw,
        fh,
        self.imageWidth,
        self.imageHeight
    )
end

local function getGridKey(...)
    return table.concat({ ... }, '-')
end

local function getOrCreateFrame(self, x, y)
    if x < 1 or x > self.width or y < 1 or y > self.height then
        error(("There is no frame for x=%d, y=%d"):format(x, y))
    end
    local key          = self._key
    _frames[key]       = _frames[key] or {}
    _frames[key][x]    = _frames[key][x] or {}
    _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
    return _frames[key][x][y]
end

local function parseInterval(str)
    if type(str) == "number" then return str, str, 1 end
    str = str:gsub('%s', '') -- remove spaces
    local min, max = str:match("^(%d+)-(%d+)$")
    assert(min and max, ("Could not parse interval from %q"):format(str))
    min, max = tonumber(min), tonumber(max)
    local step = min <= max and 1 or -1
    return min, max, step
end

function Grid:getFrames(...)
    local result, args = {}, { ... }
    local minx, maxx, stepx, miny, maxy, stepy

    for i = 1, #args, 2 do
        minx, maxx, stepx = parseInterval(args[i])
        miny, maxy, stepy = parseInterval(args[i + 1])
        for y = miny, maxy, stepy do
            for x = minx, maxx, stepx do
                result[#result + 1] = getOrCreateFrame(self, x, y)
            end
        end
    end

    return result
end

local Gridmt = {
    __index = Grid,
    __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
    assertPositiveInteger(frameWidth, "frameWidth")
    assertPositiveInteger(frameHeight, "frameHeight")
    assertPositiveInteger(imageWidth, "imageWidth")
    assertPositiveInteger(imageHeight, "imageHeight")

    left       = left or 0
    top        = top or 0
    border     = border or 0

    local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

    local grid = setmetatable(
        {
            frameWidth  = frameWidth,
            frameHeight = frameHeight,
            imageWidth  = imageWidth,
            imageHeight = imageHeight,
            left        = left,
            top         = top,
            border      = border,
            width       = math.floor(imageWidth / frameWidth),
            height      = math.floor(imageHeight / frameHeight),
            _key        = key
        },
        Gridmt
    )
    return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
    local result = {}
    for i = 1, #arr do result[i] = arr[i] end
    return result
end

local function parseDurations(durations, frameCount)
    local result = {}
    if type(durations) == 'number' then
        for i = 1, frameCount do result[i] = durations end
    else
        local min, max, step
        for key, duration in pairs(durations) do
            assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
            min, max, step = parseInterval(key)
            for i = min, max, step do result[i] = duration end
        end
    end

    if #result < frameCount then
        error("The durations table has length of " ..
        tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
    end

    return result
end

local function parseIntervals(durations)
    local result, time = { 0 }, 0
    for i = 1, #durations do
        time = time + durations[i]
        result[i + 1] = time
    end
    return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
    local td = type(durations);
    if (td ~= 'number' or durations <= 0) and td ~= 'table' then
        error("durations must be a positive number. Was " .. tostring(durations))
    end
    onLoop = onLoop or nop
    durations = parseDurations(durations, #frames)
    local intervals, totalDuration = parseIntervals(durations)
    return setmetatable({
            frames        = cloneArray(frames),
            durations     = durations,
            intervals     = intervals,
            totalDuration = totalDuration,
            onLoop        = onLoop,
            timer         = 0,
            position      = 1,
            status        = "playing",
            flippedH      = false,
            flippedV      = false
        },
        Animationmt
    )
end

function Animation:clone()
    local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
    newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
    return newAnim
end

function Animation:flipH()
    self.flippedH = not self.flippedH
    return self
end

function Animation:flipV()
    self.flippedV = not self.flippedV
    return self
end

local function seekFrameIndex(intervals, timer)
    local high, low, i = #intervals - 1, 1, 1

    while (low <= high) do
        i = math.floor((low + high) / 2)
        if timer >= intervals[i + 1] then
            low = i + 1
        elseif timer < intervals[i] then
            high = i - 1
        else
            return i
        end
    end

    return i
end

function Animation:update(dt)
    if self.status ~= "playing" then return end

    self.timer = self.timer + dt
    local loops = math.floor(self.timer / self.totalDuration)
    if loops ~= 0 then
        self.timer = self.timer - self.totalDuration * loops
        local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
        f(self, loops)
    end

    self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
    self.status = "paused"
end

function Animation:gotoFrame(position)
    self.position = position
    self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
    self.position = #self.frames
    self.timer = self.totalDuration
    self:pause()
end

function Animation:pauseAtStart()
    self.position = 1
    self.timer = 0
    self:pause()
end

function Animation:resume()
    self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)
    love.graphics.draw(image, self:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky))
end

function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)
    local frame = self.frames[self.position]
    if self.flippedH or self.flippedV then
        r, sx, sy, ox, oy, kx, ky = r or 0, sx or 1, sy or 1, ox or 0, oy or 0, kx or 0, ky or 0
        local _, _, w, h = frame:getViewport()

        if self.flippedH then
            sx = sx * -1
            ox = w - ox
            kx = kx * -1
            ky = ky * -1
        end

        if self.flippedV then
            sy = sy * -1
            oy = h - oy
            kx = kx * -1
            ky = ky * -1
        end
    end
    return frame, x, y, r, sx, sy, ox, oy, kx, ky
end

function Animation:getDimensions()
    local _, _, w, h = self.frames[self.position]:getViewport()
    return w, h
end

-----------------------------------------------------------

anim8.newGrid      = newGrid
anim8.newAnimation = newAnimation

return anim8

================
File: lib/moonshine/boxblur.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local radius_x, radius_y = 3, 3
  local shader = love.graphics.newShader[[
    extern vec2 direction;
    extern number radius;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      vec4 c = vec4(0.0);

      for (float i = -radius; i <= radius; i += 1.0)
      {
        c += Texel(texture, tc + i * direction);
      }
      return c / (2.0 * radius + 1.0) * color;
    }]]

  local setters = {}
  setters.radius = function(v)
    if type(v) == "number" then
      radius_x, radius_y = v, v
    elseif type(v) == "table" and #v >= 2 then
      radius_x, radius_y = tonumber(v[1] or v.h or v.x), tonumber(v[2] or v.v or v.y)
    else
      error("Invalid argument `radius'")
    end
  end
  setters.radius_x = function(v) radius_x = tonumber(v) end
  setters.radius_y = function(v) radius_y = tonumber(v) end

  local draw = function(buffer)
    shader:send('direction', {1 / love.graphics.getWidth(), 0})
    shader:send('radius', math.floor(radius_x + .5))
    moonshine.draw_shader(buffer, shader)

    shader:send('direction', {0, 1 / love.graphics.getHeight()})
    shader:send('radius', math.floor(radius_y + .5))
    moonshine.draw_shader(buffer, shader)
  end

  return moonshine.Effect{
    name = "boxblur",
    draw = draw,
    setters = setters,
    defaults = {radius = 3}
  }
end

================
File: lib/moonshine/chromasep.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern vec2 direction;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _)
    {
      return color * vec4(
        Texel(texture, tc - direction).r,
        Texel(texture, tc).g,
        Texel(texture, tc + direction).b,
        1.0);
    }]]

  local angle, radius = 0, 0
  local setters = {
    angle  = function(v) angle  = tonumber(v) or 0 end,
    radius = function(v) radius = tonumber(v) or 0 end
  }

  local draw = function(buffer, effect)
    local dx = math.cos(angle) * radius / love.graphics.getWidth()
    local dy = math.sin(angle) * radius / love.graphics.getHeight()
    shader:send("direction", {dx,dy})
    moonshine.draw_shader(buffer, shader)
  end

  return moonshine.Effect{
    name = "chromasep",
    draw = draw,
    setters = setters,
    defaults = {angle = 0, radius = 0}
  }
end

================
File: lib/moonshine/colorgradesimple.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern vec3 factors;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      return vec4(factors, 1.0) * Texel(texture, tc) * color;
    }]]

  local setters = {}

  return moonshine.Effect{
    name = "colorgradesimple",
    shader = shader,
    setters = {factors = function(v) shader:send("factors", v) end},
    defaults = {factors = {1,1,1}}
  }
end

================
File: lib/moonshine/crt.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  -- Barrel distortion adapted from Daniel Oaks (see commit cef01b67fd)
  -- Added feather to mask out outside of distorted texture
  local distortionFactor
  local shader = love.graphics.newShader[[
    extern vec2 distortionFactor;
    extern vec2 scaleFactor;
    extern number feather;

    vec4 effect(vec4 color, Image tex, vec2 uv, vec2 px) {
      // to barrel coordinates
      uv = uv * 2.0 - vec2(1.0);

      // distort
      uv *= scaleFactor;
      uv += (uv.yx*uv.yx) * uv * (distortionFactor - 1.0);
      number mask = (1.0 - smoothstep(1.0-feather,1.0,abs(uv.x)))
                  * (1.0 - smoothstep(1.0-feather,1.0,abs(uv.y)));

      // to cartesian coordinates
      uv = (uv + vec2(1.0)) / 2.0;

      return color * Texel(tex, uv) * mask;
    }
  ]]

  local setters = {}

  setters.distortionFactor = function(v)
    assert(type(v) == "table" and #v == 2, "Invalid value for `distortionFactor'")
    distortionFactor = {unpack(v)}
    shader:send("distortionFactor", v)
  end

  setters.x = function(v) setters.distortionFactor{v, distortionFactor[2]} end
  setters.y = function(v) setters.distortionFactor{distortionFactor[1], v} end

  setters.scaleFactor = function(v)
    if type(v) == "table" and #v == 2 then
      shader:send("scaleFactor", v)
    elseif type(v) == "number" then
      shader:send("scaleFactor", {v,v})
    else
      error("Invalid value for `scaleFactor'")
    end
  end

  setters.feather = function(v) shader:send("feather", v) end

  local defaults = {
    distortionFactor = {1.06, 1.065},
    feather = 0.02,
    scaleFactor = 1,
  }

  return moonshine.Effect{
    name = "crt",
    shader = shader,
    setters = setters,
    defaults = defaults
  }
end

================
File: lib/moonshine/desaturate.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern vec4 tint;
    extern number strength;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      color = Texel(texture, tc);
      number luma = dot(vec3(0.299, 0.587, 0.114), color.rgb);
      return mix(color, tint * luma, strength);
    }]]

  local setters = {}

  setters.tint = function(c)
    assert(type(c) == "table" and #c == 3, "Invalid value for `tint'")
    shader:send("tint", {
      (tonumber(c[1]) or 0) / 255,
      (tonumber(c[2]) or 0) / 255,
      (tonumber(c[3]) or 0) / 255,
      1
    })
  end

  setters.strength = function(v)
    shader:send("strength", math.max(0, math.min(1, tonumber(v) or 0)))
  end

  local defaults = {tint = {255,255,255}, strength = 0.5}

  return moonshine.Effect{
    name = "desaturate",
    shader = shader,
    setters = setters,
    defaults = defaults
  }
end

================
File: lib/moonshine/dmg.lua
================
--[[
The MIT License (MIT)

Original code: Copyright (c) 2015 Josef Patoprsty
Port to moonshine: Copyright (c) 2017 Matthias Richter <vrld@vrld.org>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]--

local palettes = {
  -- Default color palette. Source:
  -- http://en.wikipedia.org/wiki/List_of_video_game_console_palettes#Original_Game_Boy
  {
    name = "default",
    colors = {
      { 15/255, 56/255, 15/255},
      { 48/255, 98/255, 48/255},
      {139/255,172/255, 15/255},
      {155/255,188/255, 15/255}
    }
  },
  -- Hardcore color profiles. Source:
  -- http://www.hardcoregaming101.net/gbdebate/gbcolours.htm
  {
    name = "dark_yellow",
    colors = {
      {33/255,32/255,16/255},
      {107/255,105/255,49/255},
      {181/255,174/255,74/255},
      {255/255,247/255,123/255}
    }
  },
  {
    name = "light_yellow",
    colors = {
      {102/255,102/255,37/255},
      {148/255,148/255,64/255},
      {208/255,208/255,102/255},
      {255/255,255/255,148/255}
    }
  },
  {
    name = "green",
    colors = {
      {8/255,56/255,8/255},
      {48/255,96/255,48/255},
      {136/255,168/255,8/255},
      {183/255,220/255,17/255}
    }
  },
  {
    name = "greyscale",
    colors = {
      {56/255,56/255,56/255},
      {117/255,117/255,117/255},
      {178/255,178/255,178/255},
      {239/255,239/255,239/255}
    }
  },
  {
    name = "stark_bw",
    colors = {
      {0/255,0/255,0/255},
      {117/255,117/255,117/255},
      {178/255,178/255,178/255},
      {255/255,255/255,255/255}
    }
  },
  {
    name = "pocket",
    colors = {
      {108/255,108/255,78/255},
      {142/255,139/255,87/255},
      {195/255,196/255,165/255},
      {227/255,230/255,201/255}
    }
  }
}

local lookup_palette = function(name)
  for _,palette in pairs(palettes) do
    if palette.name == name then
      return palette
    end
  end
end

local is_valid_palette = function(v)
  -- Needs to match: {{R,G,B},{R,G,B},{R,G,B},{R,G,B}}
  if #v ~= 4 then return false end

  for i = 1,4 do
    if type(v[i]) ~= "table" or #v[i] ~= 3 then return false end
    for c = 1,3 do
      if type(v[i][c]) ~= "number" then return false end
      local x = v[i][c]
      if x > 1 then x = x / 255 end
      if x < 0 or x > 1 then return false end
      v[i][c] = x
    end
  end
  return true
end

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern vec3 palette[ 4 ];

    vec4 effect(vec4 color, Image texture, vec2 texture_coords, vec2 pixel_coords) {
      vec4 pixel = Texel(texture, texture_coords);
      float avg = min(0.9999,max(0.0001,(pixel.r + pixel.g + pixel.b)/3));
      int index = int(avg*4);
      return vec4(palette[index], pixel.a);
    }]]

  local setters = {}
  setters.palette = function(v)
    if type(v) == "number" and palettes[math.floor(v)] then -- indexed palette
      palette = palettes[math.floor(v)]
    elseif type(v) == "string" then -- named palette
      palette = lookup_palette(v)
    elseif type(v) == "table" and is_valid_palette(v) then -- custom palette
      palette = {colors=v}
    else -- Fall back to default
      palette = palettes[1]
    end
    shader:send("palette", palette.colors[1], palette.colors[2],
                           palette.colors[3], palette.colors[4], {})
  end

  return moonshine.Effect{
    name = "dmg",
    shader = shader,
    setters = setters,
    defaults = {palette = "default"}
  }
end

================
File: lib/moonshine/fastgaussianblur.lua
================
--[[
The MIT License (MIT)

Copyright (c) 2017 Tim Moore
Adapted for new moonshine API by Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]--

-- Bilinear Gaussian blur filter as detailed here: http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/
-- Produces near identical results to a standard Gaussian blur by using sub-pixel sampling,
-- this allows us to do ~1/2 the number of pixel lookups.

-- unroll convolution loop
local function build_shader(taps, offset, offset_type, sigma)
  taps = math.floor(taps)
  sigma = sigma >= 1 and sigma or (taps - 1) * offset / 6
  sigma = math.max(sigma, 1)

  local steps = (taps + 1) / 2

  -- Calculate gaussian function.
  local g_offsets = {}
  local g_weights = {}
  for i = 1, steps, 1 do
		g_offsets[i] = offset * (i - 1)

    -- We don't need to include the constant part of the gaussian function as we normalize later.
    -- 1 / math.sqrt(2 * sigma ^ math.pi) * math.exp(-0.5 * ((offset - 0) / sigma) ^ 2 )
    g_weights[i] = math.exp(-0.5 * (g_offsets[i] - 0) ^ 2 * 1 / sigma ^ 2 )
  end

  -- Calculate offsets and weights for sub-pixel samples.
  local offsets = {}
  local weights = {}
  for i = #g_weights, 2, -2 do
    local oA, oB = g_offsets[i], g_offsets[i - 1]
    local wA, wB = g_weights[i], g_weights[i - 1]
    wB = oB == 0 and wB / 2 or wB -- On center tap the middle is getting sampled twice so half weight.
    local weight = wA + wB
    offsets[#offsets + 1] = offset_type == 'center' and (oA + oB) / 2 or (oA * wA + oB * wB) / weight
    weights[#weights + 1] = weight
  end

  local code = {[[
    extern vec2 direction;
    vec4 effect(vec4 color, Image tex, vec2 tc, vec2 sc) {]]}

  local norm = 0
  if #g_weights % 2 == 0 then
    code[#code+1] =  'vec4 c = vec4( 0.0 );'
  else
    local weight = g_weights[1]
    norm = norm + weight
    code[#code+1] = ('vec4 c = %f * texture2D(tex, tc);'):format(weight)
  end

  local tmpl = 'c += %f * ( texture2D(tex, tc + %f * direction)+ texture2D(tex, tc - %f * direction));\n'
  for i = 1, #offsets, 1 do
    local offset = offsets[i]
    local weight = weights[i]
    norm = norm + weight * 2
    code[#code+1] = tmpl:format(weight, offset, offset)
  end
  code[#code+1] = ('return c * vec4(%f) * color; }'):format(1 / norm)

  local shader = table.concat(code)
  return love.graphics.newShader(shader)
end

return function(moonshine)
  local taps, offset, offset_type, sigma = 7, 1, 'weighted', -1
  local shader = build_shader(taps, offset, offset_type, sigma)

  local function draw(buffer)
    shader:send('direction', {1 / love.graphics.getWidth(), 0})
    moonshine.draw_shader(buffer, shader)

    shader:send('direction', {0, 1 / love.graphics.getHeight()})
    moonshine.draw_shader(buffer, shader)
  end

  local setters = {}

  -- Number of effective samples to take per pass. e.g. 3-tap is the current pixel and the neighbors each side.
  -- More taps = larger blur, but slower.
  setters.taps = function(v)
    assert(tonumber(v) >= 3, "Invalid value for `taps': Must be >= 3")
    assert(tonumber(v)%2 == 1, "Invalid value for `taps': Must be odd")
    taps = tonumber(v)
    shader = build_shader(taps, offset, offset_type, sigma)
  end

  -- Offset of each tap.
  -- For highest quality this should be <=1 but if the image has low entropy we
  -- can approximate the blur with a number > 1 and less taps, for better performance.
  setters.offset =  function(v)
    offset = tonumber(v) or 0
    shader = build_shader(taps, offset, offset_type, sigma)
  end

  -- Offset type, either 'weighted' or 'center'.
  -- 'weighted' gives a more accurate gaussian decay but can introduce modulation
  -- for high frequency details.
  setters.offset_type = function(v)
    assert(v == 'weighted' or v == 'center', "Invalid value for 'offset_type': Must be 'weighted' or 'center'.")
    offset_type = v
    shader = build_shader(taps, offset, offset_type, sigma)
  end

  -- Sigma value for gaussian distribution. You don't normally need to set this.
  setters.sigma =  function(v)
    sigma = tonumber(v) or -1
    shader = build_shader(taps, offset, offset_type, sigma)
  end

  return moonshine.Effect{
    name = "fastgaussianblur",
    draw = draw,
    setters = setters,
    -- no defaults here, as we dont want the shader to be built 3 times on startup
  }
end

================
File: lib/moonshine/filmgrain.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local noisetex = love.image.newImageData(256,256)
  noisetex:mapPixel(function()
    local l = love.math.random() * 255
    return l,l,l,l
  end)
  noisetex = love.graphics.newImage(noisetex)

  local shader = love.graphics.newShader[[
    extern number opacity;
    extern number size;
    extern vec2 noise;
    extern Image noisetex;
    extern vec2 tex_ratio;

    float rand(vec2 co) {
      return Texel(noisetex, mod(co * tex_ratio / vec2(size), vec2(1.0))).r;
    }

    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      return color * Texel(texture, tc) * mix(1.0, rand(tc+vec2(noise)), opacity);
    }]]

  shader:send("noisetex", noisetex)
  shader:send("tex_ratio", {love.graphics.getWidth() / noisetex:getWidth(),
                            love.graphics.getHeight() / noisetex:getHeight()})

  local setters = {}
  for _,k in ipairs{"opacity", "size"} do
    setters[k] = function(v) shader:send(k, math.max(0, tonumber(v) or 0)) end
  end

  local defaults = {opacity = .3, size = 1}

  local draw = function(buffer)
    shader:send("noise", {love.math.random(), love.math.random()})
    moonshine.draw_shader(buffer, shader)
  end

  return moonshine.Effect{
    name = "filmgrain",
    draw = draw,
    setters = setters,
    defaults = defaults
  }
end

================
File: lib/moonshine/fog.lua
================
--[[
Animated 2D Fog (procedural)
Originally for Godot Engine by Gonkee https://www.youtube.com/watch?v=QEaTsz_0o44&t=6s

Translated for l√∂ve by Brandon Blanker Lim-it @flamendless
]]--

--[[
SAMPLE USAGE:
local moonshine = require("moonshine")
local effect

local image, bg
local image_data
local shader_fog
local time = 0

function love.load()
	image_data = love.image.newImageData(love.graphics.getWidth(), love.graphics.getHeight())
	image = love.graphics.newImage(image_data)
	bg = love.graphics.newImage("bg.png")
	effect = moonshine(moonshine.effects.fog)
	effect.fog.fog_color = {0.1, 0.0, 0.0}
	effect.fog.speed = {0.2, 0.9}
end

function love.update(dt)
	time = time + dt
	effect.fog.time = time
end

function love.draw()
	love.graphics.draw(bg)
	effect(function()
		love.graphics.draw(image)
	end)
end
]]

return function(moonshine)
	local fog_color
	local octaves
	local speed
	local time

	local shader = love.graphics.newShader([[
		extern vec3 fog_color = vec3(0.35, 0.48, 0.95);
		extern int octaves = 4;
		extern vec2 speed = vec2(0.0, 1.0);
		extern float time;

		float rand(vec2 coord)
		{
			return fract(sin(dot(coord, vec2(56, 78)) * 1000.0) * 1000.0);
		}

		float noise(vec2 coord)
		{
			vec2 i = floor(coord); //get the whole number
			vec2 f = fract(coord); //get the fraction number
			float a = rand(i); //top-left
			float b = rand(i + vec2(1.0, 0.0)); //top-right
			float c = rand(i + vec2(0.0, 1.0)); //bottom-left
			float d = rand(i + vec2(1.0, 1.0)); //bottom-right
			vec2 cubic = f * f * (3.0 - 2.0 * f);
			return mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y; //interpolate
		}

		float fbm(vec2 coord) //fractal brownian motion
		{
			float value = 0.0;
			float scale = 0.5;
			for (int i = 0; i < octaves; i++)
			{
				value += noise(coord) * scale;
				coord *= 2.0;
				scale *= 0.5;
			}
			return value;
		}

		vec4 effect(vec4 color, Image texture, vec2 tc, vec2 sc)
		{
			vec2 coord = tc * 20.0;
			vec2 motion = vec2(fbm(coord + vec2(time * speed.x, time * speed.y)));
			float final = fbm(coord + motion);
			return vec4(fog_color, final * 0.5);
		}
	]])

	local setters = {}

	setters.fog_color = function(t)
		assert(type(t) == "table", "Passed argument to fog_color must be a table containing 3 color values")
		fog_color = t
		shader:send("fog_color", fog_color)
	end

	setters.octaves = function(i)
		assert(type(i) == "number", "Passed argument to octaves must be an integer")
		octaves = i
		shader:send("octaves", octaves)
	end

	setters.speed = function(t)
		assert(type(t) == "table", "Passed argument to speed must be a table containing 2 values")
		speed = t
		shader:send("speed", speed)
	end

	setters.time = function(n)
		assert(type(n) == "number", "Passed argument to time must be a number")
		time = n
		shader:send("time", time)
	end

	local defaults = {
		fog_color = {0.35, 0.48, 0.95},
		octaves = 4,
		speed = {0.5, 0.5},
	}

	return moonshine.Effect({
		name = "fog",
		shader = shader,
		setters = setters,
		defaults = defaults,
	})
end

================
File: lib/moonshine/gaussianblur.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
]]--
local function resetShader(sigma)
  local support = math.max(1, math.floor(3*sigma + .5))
  local one_by_sigma_sq = sigma > 0 and 1 / (sigma * sigma) or 1
  local norm = 0

  local code = {[[
    extern vec2 direction;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _)
    { vec4 c = vec4(0.0);
  ]]}
  local blur_line = "c += vec4(%f) * Texel(texture, tc + vec2(%f) * direction);"

  for i = -support,support do
    local coeff = math.exp(-.5 * i*i * one_by_sigma_sq)
    norm = norm + coeff
    code[#code+1] = blur_line:format(coeff, i)
  end

  code[#code+1] = ("return c * vec4(%f) * color;}"):format(norm > 0 and 1/norm or 1)

  return love.graphics.newShader(table.concat(code))
end

return function(moonshine)
  local shader

  local setters = {}
  setters.sigma = function(v)
    shader = resetShader(math.max(0,tonumber(v) or 1))
  end

  local draw = function(buffer)
    shader:send('direction', {1 / love.graphics.getWidth(), 0})
    moonshine.draw_shader(buffer, shader)

    shader:send('direction', {0, 1 / love.graphics.getHeight()})
    moonshine.draw_shader(buffer, shader)
  end

  return moonshine.Effect{
    name = "gaussianblur",
    draw = draw,
    setters = setters,
    defaults = {sigma = 1},
  }
end

================
File: lib/moonshine/glow.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--


-- unroll convolution loop for gaussian blur shader
local function make_blur_shader(sigma)
  local support = math.max(1, math.floor(3*sigma + .5))
  local one_by_sigma_sq = sigma > 0 and 1 / (sigma * sigma) or 1
  local norm = 0

  local code = {[[
    extern vec2 direction;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      vec4 c = vec4(0.0);
  ]]}
  local blur_line = "c += vec4(%f) * Texel(texture, tc + vec2(%f) * direction);"

  for i = -support,support do
    local coeff = math.exp(-.5 * i*i * one_by_sigma_sq)
    norm = norm + coeff
    code[#code+1] = blur_line:format(coeff, i)
  end

  code[#code+1] = ("return c * vec4(%f) * color;}"):format(1 / norm)

  return love.graphics.newShader(table.concat(code))
end

return function(moonshine)
  local blurshader -- set in setters.glow_strength
  local threshold = love.graphics.newShader[[
    extern number min_luma;
    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      vec4 c = Texel(texture, tc);
      number luma = dot(vec3(0.299, 0.587, 0.114), c.rgb);
      return c * step(min_luma, luma) * color;
    }]]

  local setters = {}
  setters.strength = function(v)
    blurshader = make_blur_shader(math.max(0,tonumber(v) or 1))
  end
  setters.min_luma = function(v)
    threshold:send("min_luma", math.max(0, math.min(1, tonumber(v) or 0.5)))
  end

  local scene = love.graphics.newCanvas()
  local draw = function(buffer)
    local front, back = buffer() -- scene so far is in `back'
    scene, back = back, scene    -- save it for second draw below

    -- 1st pass: draw scene with brightness threshold
    love.graphics.setCanvas(front)
    love.graphics.clear()
    love.graphics.setShader(threshold)
    love.graphics.draw(scene)

    -- 2nd pass: apply blur shader in x
    blurshader:send('direction', {1 / love.graphics.getWidth(), 0})
    love.graphics.setCanvas(back)
    love.graphics.clear()
    love.graphics.setShader(blurshader)
    love.graphics.draw(front)

    -- 3nd pass: apply blur shader in y and draw original and blurred scene
    love.graphics.setCanvas(front)
    love.graphics.clear()

    -- original scene without blur shader
    love.graphics.setShader()
    love.graphics.setBlendMode("add", "premultiplied")
    love.graphics.draw(scene) -- original scene

    -- second pass of light blurring
    blurshader:send('direction', {0, 1 / love.graphics.getHeight()})
    love.graphics.setShader(blurshader)
    love.graphics.draw(back)

    -- restore things as they were before entering draw()
    love.graphics.setBlendMode("alpha", "premultiplied")
    scene = back
  end

  return moonshine.Effect{
    name = "glow",
    draw = draw,
    setters = setters,
    defaults = {min_luma=.7, strength = 5}
  }
end

================
File: lib/moonshine/godsray.lua
================
--[[
The MIT License (MIT)

Original code: Copyright (c) 2015 Josef Patoprsty
Port to moonshine: Copyright (c) 2017 Matthias Richter <vrld@vrld.org>

Based on work by: ioxu

https://www.love2d.org/forums/viewtopic.php?f=4&t=3733&start=120#p71099

Based on work by: Fabien Sanglard

http://fabiensanglard.net/lightScattering/index.php

Based on work from:

[Mitchell]: Kenny Mitchell "Volumetric Light Scattering as a Post-Process" GPU Gems 3 (2005).
[Mitchell2]: Jason Mitchell "Light Shaft Rendering" ShadersX3 (2004).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern number exposure;
    extern number decay;
    extern number density;
    extern number weight;
    extern vec2 light_position;
    extern number samples;

    vec4 effect(vec4 color, Image tex, vec2 uv, vec2 px) {
      color = Texel(tex, uv);

      vec2 offset = (uv - light_position) * density / samples;
      number illumination = decay;
      vec4 c = vec4(.0, .0, .0, 1.0);

      for (int i = 0; i < int(samples); ++i) {
        uv -= offset;
        c += Texel(tex, uv) * illumination * weight;
        illumination *= decay;
      }

      return vec4(c.rgb * exposure + color.rgb, color.a);
    }]]


  local setters, light_position = {}

  for _,k in ipairs{"exposure", "decay", "density", "weight"} do
    setters[k] = function(v)
      shader:send(k, math.min(1, math.max(0, tonumber(v) or 0)))
    end
  end

  setters.light_position = function(v)
    light_position = {unpack(v)}
    shader:send("light_position", v)
  end

  setters.light_x = function(v)
    assert(type(v) == "number", "Invalid value for `light_x'")
    setters.light_position{v, light_position[2]}
  end

  setters.light_y = function(v)
    assert(type(v) == "number", "Invalid value for `light_y'")
    setters.light_position{light_position[1], v}
  end

  setters.samples = function(v)
    shader:send("samples", math.max(1,tonumber(v) or 1))
  end

  local defaults = {
    exposure = 0.25,
    decay = 0.95,
    density = 0.15,
    weight = 0.5,
    light_position = {0.5,0.5},
    samples = 70
  }

  return moonshine.Effect{
    name = "godsray",
    shader = shader,
    setters = setters,
    defaults = defaults
  }
end

================
File: lib/moonshine/init.lua
================
--[[
The MIT License (MIT)

Copyright (c) 2017 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]--

local BASE = ...

local moonshine = {}

moonshine.draw_shader = function(buffer, shader)
  local front, back = buffer()
  love.graphics.setCanvas(front)
  love.graphics.clear()
  if shader ~= love.graphics.getShader() then
    love.graphics.setShader(shader)
  end
  love.graphics.draw(back)
end

moonshine.chain = function(w,h,effect)
  -- called as moonshine.chain(effect)'
  if h == nil then
    effect, w,h = w, love.window.getMode()
  end
  assert(effect ~= nil, "No effect")

  local front, back = love.graphics.newCanvas(w,h), love.graphics.newCanvas(w,h)
  local buffer = function()
    back, front = front, back
    return front, back
  end

  local disabled = {} -- set of disabled effects
  local chain = {}
  chain.resize = function(w, h)
    front, back = love.graphics.newCanvas(w,h), love.graphics.newCanvas(w,h)
    return chain
  end

  chain.draw = function(func, ...)
    -- save state
    local canvas = love.graphics.getCanvas()
    local shader = love.graphics.getShader()
    local fg_r, fg_g, fg_b, fg_a = love.graphics.getColor()

    -- draw scene to front buffer
    love.graphics.setCanvas((buffer())) -- parens are needed: take only front buffer
    love.graphics.clear(love.graphics.getBackgroundColor())
    func(...)

    -- save more state
    local blendmode = love.graphics.getBlendMode()

    -- process all shaders
    love.graphics.setColor(fg_r, fg_g, fg_b, fg_a)
    love.graphics.setBlendMode("alpha", "premultiplied")
    for _,e in ipairs(chain) do
      if not disabled[e.name] then
        (e.draw or moonshine.draw_shader)(buffer, e.shader)
      end
    end

    -- present result
    love.graphics.setShader()
    love.graphics.setCanvas(canvas)
    love.graphics.draw(front,0,0)

    -- restore state
    love.graphics.setBlendMode(blendmode)
    love.graphics.setShader(shader)
  end

  chain.next = function(e)
    if type(e) == "function" then
      e = e()
    end
    assert(e.name, "Invalid effect: must provide `name'.")
    assert(e.shader or e.draw, "Invalid effect: must provide `shader' or `draw'.")
    table.insert(chain, e)
    return chain
  end
  chain.chain = chain.next

  chain.disable = function(name, ...)
    if name then
      disabled[name] = name
      return chain.disable(...)
    end
  end

  chain.enable = function(name, ...)
    if name then
      disabled[name] = nil
      return chain.enable(...)
    end
  end

  setmetatable(chain, {
    __call = function(_, ...) return chain.draw(...) end,
    __index = function(_,k)
      for _, e in ipairs(chain) do
        if e.name == k then return e end
      end
      error(("Effect `%s' not in chain"):format(k), 2)
    end,
    __newindex = function(_, k, v)
      if k == "parameters" or k == "params" or k == "settings" then
        for e,par in pairs(v) do
          for k,v in pairs(par) do
            chain[e][k] = v
          end
        end
      else
        rawset(chain, k, v)
      end
    end
  })

  return chain.next(effect)
end

moonshine.Effect = function(e)
  -- set defaults
  for k,v in pairs(e.defaults or {}) do
    assert(e.setters[k], ("No setter for parameter `%s'"):format(k))(v, k)
    e.setters[k](v,k)
  end

  -- expose setters
  return setmetatable(e, {
    __newindex = function(self,k,v)
      assert(self.setters[k], ("Unknown property: `%s.%s'"):format(e.name, k))
      self.setters[k](v, k)
    end})
end

-- autoloading effects
moonshine.effects = setmetatable({}, {__index = function(self, key)
  local ok, effect = pcall(require, BASE .. "." .. key)
  if not ok then
    error("No such effect: "..key, 2)
  end

  -- expose moonshine to effect
  local con = function(...) return effect(moonshine, ...) end

  -- cache effect constructor
  self[key] = con
  return con
end})

return setmetatable(moonshine, {__call = function(_, ...) return moonshine.chain(...) end})

================
File: lib/moonshine/pixelate.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern vec2 size;
    extern number feedback;
    vec4 effect(vec4 color, Image tex, vec2 tc, vec2 _)
    {
      vec4 c = Texel(tex, tc);

      // average pixel color over 5 samples
      vec2 scale = love_ScreenSize.xy / size;
      tc = floor(tc * scale + vec2(.5));
      vec4 meanc = Texel(tex, tc/scale);
      meanc += Texel(tex, (tc+vec2( 1.0,  .0))/scale);
      meanc += Texel(tex, (tc+vec2(-1.0,  .0))/scale);
      meanc += Texel(tex, (tc+vec2(  .0, 1.0))/scale);
      meanc += Texel(tex, (tc+vec2(  .0,-1.0))/scale);

      return color * mix(.2*meanc, c, feedback);
    }
  ]]

  local setters = {}
  setters.size = function(v)
    if type(v) == "number" then v = {v,v} end
    assert(type(v) == "table" and #v == 2, "Invalid value for `size'")
    shader:send("size", v)
  end
  setters.feedback = function(v)
    shader:send("feedback", math.min(1, math.max(0, tonumber(v) or 0)))
  end

  return moonshine.Effect{
    name = "pixelate",
    shader = shader,
    setters = setters,
    defaults = {size = {5,5}, feedback = 0}
  }
end

================
File: lib/moonshine/posterize.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

shader based on code by sam hocevar, see
https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern number num_bands;
    vec3 rgb2hsv(vec3 c)
    {
      vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
      vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
      vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

      float d = q.x - min(q.w, q.y);
      float e = 1.0e-10;
      return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    vec3 hsv2rgb(vec3 c)
    {
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _)
    {
      color = Texel(texture, tc);
      vec3 hsv = floor((rgb2hsv(color.rgb) * num_bands) + vec3(0.5)) / num_bands;
      return vec4(hsv2rgb(hsv), color.a);
    }]]

  return moonshine.Effect{
    name = "posterize",
    shader = shader,
    setters = {
      num_bands = function(v)
        shader:send("num_bands", math.max(1, tonumber(v) or 1))
      end
    },
    defaults = {num_bands = 3}
  }
end

================
File: lib/moonshine/README.md
================
# moonshine

Chainable post-processing shaders for L√ñVE.

## Overview

* [Getting started](#getting-started)
* [General usage](#general-usage)
* [List of effects](#list-of-effects)
* [Writing effects](#writing-effects)
* [License](#license)

<a name="getting-started"></a>
## Getting started

Clone this repository into your game folder:

    git clone https://github.com/vrld/moonshine.git

This will create the folder `moonshine`.

In your `main.lua`, or wherever you load your libraries, add the following:

```lua
local moonshine = require 'moonshine'
```

Create and parametrize the post-processing effect in `love.load()`, for example:

```lua
function love.load()
  effect = moonshine(moonshine.effects.filmgrain)
                    .chain(moonshine.effects.vignette)
  effect.filmgrain.size = 2
end
```

Lastly, wrap the things you want to be drawn with the effect inside a function:

```lua
function love.draw()
    effect(function()
      love.graphics.rectangle("fill", 300,200, 200,200)
    end)
end
```

When you package your game for release, you might want consider deleting the
(hidden) `.git` folder in the moonshine directory.


<a name="general-usage"></a>
## General usage

The main concept behind moonshine are chains. A chain consists of one or more
effects. Effects that come later in the chain will be applied to the result of
the effects that come before. In the example above, the vignette is drawn on
top of the filmgrain.

### Chains

Chains are created using the `moonshine.chain` function:

```lua
chain = moonshine.chain(effect)
```

For convenience, `moonshine(effect)` is an alias to `moonshine.chain(effect)`.
You can add new effects to a chain using

```lua
chain = chain.chain(another_effect)
```

or using `chain.next()`, which is an alias to `chain.chain()`.
As the function returns the chain, you can specify your whole chain in one go,
as shown in the example above.

### Effects and effect parameters

The effects that come bundled with moonshine (see [List of effects](#list-of-effects))
are accessed by `chain.effects.<effect-name>`, e.g.,

```lua
moonshine.effects.glow
```

Most effects are parametrized to change how they look. In the example above,
the size of the grains was set to 2 pixels (the default is 1 pixel).
Effect parameters are set by first specifying the name of the effect and then
the name of the parameter:

```lua
chain.<effect>.<parameter> = <value>
```

For example, if `chain` contained the `glow` and `crt` effects, you can set the
glow `strength` parameter and crt `distortionFactor` parameter as such:

```lua
chain.glow.strength = 10
chain.crt.distortionFactor = {1.06, 1.065}
```

Because you likely initialize a bunch of parameters at once, you can set all
parameters with the special key `parameters` (or `params` or `settings`). This
is equivalent to the above:

```lua
chain.parameters = {
  glow = {strength = 10},
  crt = {distortionFactor = {1.06, 1.065}},
}
```

Note that this will only set the parameters specified in the table. The crt
parameter `feather`, for example, will be left untouched.

### Drawing effects

Creating effects and setting parameters is fine, but not very useful on its
own. You also need to apply it to something. This is done using `chain.draw()`:

```lua
chain.draw(func, ...)
```

This will apply the effect to everything that is drawn inside `func(...)`.
Everything that is drawn outside of `func(...)` will not be affected. For
example,

```lua
love.graphics.draw(img1, 0,0)
chain.draw(function()
  love.graphics.draw(img2, 200,0)
end)
love.graphics.draw(img3, 400,0)
```

will apply the effect to `img2`, but not to `img1` and `img3`. Note that some
effects (like filmgrain) draw on the whole screen. So if in this example `chain`
would consist of a gaussianblur and filmgrain effect, `img1` will be covered
with grain, but will not be blurred, `img2` will get both effects, and `img3`
will be left untouched.

Similar to chain creation, `chain(func, ...)` is an alias to the more verbose
`chain.draw(func, ...)`.

### Temporarily disabling effects

You can disable effects in a chain by using `chain.disable(names...)` and
`chain.enable(names...)`.
For example,

```lua
effect = moonshine(moonshine.effects.boxblur)
                  .chain(moonshine.effects.filmgrain)
                  .chain(moonshine.effects.vignette)
effect.disable("boxblur", "filmgrain")
effect.enable("filmgrain")
```

would first disable the boxblur and filmgrain effect, and then enable the
filmgrain again.
Note that the effects are still in the chain, they are only not drawn.

### Canvas size

You can change the size of the internal canvas, for example when the window was
resized, by calling `chain.resize(width, height)`.
Do this anytime you want, but best not during `chain.draw()`.

You can also specify the initial canvas size by starting the chain like this:

```lua
effect = moonshine(400,300, moonshine.effects.vignette)
```

That is, you specify the width and height before the first effect in the chain.

### Is this efficient?

Of course, using moonshine is not as efficient as writing your own shader that
does all the effects you want in the least amount of passes, but moonshine
tries to minimize the overhead.

On the other hand, you don't waste time writing the same shader over and over
again when using moonshine: You're trading a small amount of computation time
for a large amount of development time.


<a name="list-of-effects"></a>
## List of effects

Currently, moonshine contains the following effects (in alphabetical order):

* [boxblur](#effect-boxblur): simple blurring
* [chromasep](#effect-chromasep): cheap/fake chromatic aberration
* [colorgradesimple](#effect-colorgradesimple): weighting of color channels
* [crt](#effect-crt): crt/barrel distortion
* [desaturate](#effect-desaturate): desaturation and tinting
* [dmg](#effect-dmg): Gameboy and other four color palettes
* [fastgaussianblur](#effect-fastgaussianblur): faster Gaussian blurring
* [filmgrain](#effect-filmgrain): image noise
* [gaussianblur](#effect-gaussianblur): Gaussian blurring
* [glow](#effect-glow): aka (light bloom
* [godsray](#effect-godsray): aka light scattering
* [pixelate](#effect-pixelate): sub-sampling (for that indie look)
* [posterize](#effect-posterize): restrict number of colors
* [scanlines](#effect-scanlines): horizontal lines
* [sketch](#effect-sketch): simulate pencil drawings
* [vignette](#effect-vignette): shadow in the corners


<a name="effect-boxblur"></a>
### boxblur

```lua
moonshine.effects.boxblur
```

**Parameters:**

Name | Type | Default
-----|------|--------
radius | number or table of numbers | {3,3}
radius_x | number | 3
radius_y | number | 3


<a name="effect-chromasep"></a>
### chromasep

```lua
moonshine.effects.chromasep
```

**Parameters:**

Name | Type | Default
-----|------|--------
angle | number (in radians) | 0
radius | number | 0


<a name="effect-colorgradesimple"></a>
### colorgradesimple

```lua
moonshine.effects.colorgradesimple
```

**Parameters:**

Name | Type | Default
-----|------|--------
factors | table of numbers | {1,1,1}


<a name="effect-crt"></a>
### crt

```lua
moonshine.effects.crt
```

**Parameters:**

Name | Type | Default
-----|------|--------
distortionFactor | table of numbers | {1.06, 1.065}
x | number | 1.06
y | number | 1.065
scaleFactor | number or table of numbers | {1,1}
feather | number | 0.02


<a name="effect-desaturate"></a>
### desaturate

```lua
moonshine.effects.desaturate
```

**Parameters:**

Name | Type | Default
-----|------|--------
tint | color / table of numbers | {255,255,255}
strength | number between 0 and 1 | 0.5


<a name="effect-dmg"></a>
### dmg

```lua
moonshine.effects.dmg
```

Name | Type | Default
-----|------|--------
palette | number or string or table of table of numbers | "default"

DMG ships with 7 palettes:

1. `default`
2. `dark_yellow`
3. `light_yellow`
4. `green`
5. `greyscale`
6. `stark_bw`
7. `pocket`

Custom palettes must be in the format `{{R,G,B}, {R,G,B}, {R,G,B}, {R,G,B}}`,
where `R`, `G`, and `B` are numbers between `0` and `255`.


<a name="effect-fastgaussianblur"></a>
### fastgaussianblur

```lua
moonshine.effects.fastgaussianblur
```

**Parameters:**

Name | Type | Default
-----|------|--------
taps | odd number >= 3 | 7 | (amount of blur)
offset | number | 1
sigma | number | -1


<a name="effect-filmgrain"></a>
### filmgrain

```lua
moonshine.effects.filmgrain
```

**Parameters:**

Name | Type | Default
-----|------|--------
opacity | number | 0.3
size | number | 1


<a name="effect-gaussianblur"></a>
### gaussianblur

```lua
moonshine.effects.gaussianblur
```

**Parameters:**

Name | Type | Default
-----|------|--------
sigma | number | 1 | (amount of blur)


<a name="effect-glow"></a>
### glow

```lua
moonshine.effects.glow
```

**Parameters:**

Name | Type | Default
-----|------|--------
min_luma | number between 0 and 1 | 0.7
strength | number >= 0 | 5


<a name="effect-godsray"></a>
### godsray

```lua
moonshine.effects.godsray
```

**Parameters:**

Name | Type | Default
-----|------|--------
exposire | number between 0 and 1 | 0.5
decay | number between 0 and 1 | 0.95
density | number between 0 and 1 | 0.05
weight | number between 0 and 1 | 0.5
light_position | table of two numbers | {0.5, 0.5}
light_x | number | 0.5
light_y | number | 0.5
samples | number >= 1 | 70


<a name="effect-pixelate"></a>
### pixelate

```lua
moonshine.effects.pixelate
```

**Parameters:**

Name | Type | Default
-----|------|--------
size | number or table of two numbers | {5,5}
feedback | number between 0 and 1 | 0


<a name="effect-posterize"></a>
### posterize

```lua
moonshine.effects.posterize
```

**Parameters:**

Name | Type | Default
-----|------|--------
num_bands | number >= 1 | 3


<a name="effect-scanlines"></a>
### scanlines

```lua
moonshine.effects.scanlines
```

**Parameters:**

Name | Type | Default
-----|------|--------
width | number | 2
frequency | number | screen-height
phase | number | 0
thickness | number | 1
opacity | number | 1
color | color / table of numbers | {0,0,0}


<a name="effect-sketch"></a>
### sketch

```lua
moonshine.effects.sketch
```

**Parameters:**

Name | Type | Default
-----|------|--------
amp | number | 0.0007
center | table of numbers | {0,0}


<a name="effect-vignette"></a>
### vignette

```lua
moonshine.effects.vignette
```

**Parameters:**

Name | Type | Default
-----|------|--------
radius | number > 0 | 0.8
softness | number > 0 | 0.5
opacity | number > 0 | 0.5
color | color / table of numbers | {0,0,0}

<a name="effect-fog"></a>
### fog

```lua
moonshine.effects.fog
```

**Parameters:**

Name | Type | Default
-----|------|--------
fog_color | color/table of numbers | {0.35, 0.48, 0.95}
octaves | number > 0 | 4
speed | vec2/table of numbers | {0.5, 0.5}


<a name="writing-effects"></a>
## Writing effects

An effect is essentially a function that returns a `moonshine.Effect{}`, which
must specify at least a `name` and a `shader` or a `draw` function.

It may also specify a `setters` table that contains functions that set the
effect parameters and a `defaults` table with the corresponding default values.
The default values will be set when the effect is instantiated.

A good starting point to see how to write effects is the `colorgradesimple`
effect, which uses the `shader`, `setters` and `defaults` fields.

Moonshine uses double buffering to draw the effects. A function to swap and
access the buffers is provided to the `draw(buffer)` function of your effect:

```lua
front, back = buffer() -- swaps front and back buffer and returns both
```

You don't have to care about canvases or restoring defaults, moonshine handles
all that for you.

If you only need a custom draw function because your effect needs multiple
shader passes, moonshine provides the `draw_shader(buffer, shader)` function.
As you might have guessed, this function uses `shader` to draw the front buffer
to the back buffer. The `boxblur` effect gives a simple example how to use this
function.

If for some reason you need more than two buffer, you are more or less on your
own. You can do everything, but make sure that the blend mode and the order of
back and front buffer is the same before and after your custom `draw` function.
The `glow` effect gives an example of a more complicated `draw` function.


<a name="license"></a>
## License

See [here](https://github.com/vrld/moonshine/graphs/contributors) for a list of
contributors.

The main library can freely be used under the following conditions:

    The MIT License (MIT)

    Copyright (c) 2017 Matthias Richter

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

Most of the effects are public domain (see comments inside the files):

* boxblur.lua
* chromasep.lua
* colorgradesimple.lua
* crt.lua
* desaturate.lua
* filmgrain.lua
* gaussianblur.lua
* glow.lua
* pixelate.lua
* posterize.lua
* scanlines.lua
* vignette.lua

These effects are MIT-licensed with multiple authors:

* dmg.lua: Joseph Patoprsty, Matthias Richter
* fastgaussianblur.lua: Tim Moore, Matthias Richter
* godsray.lua: Joseph Patoprsty, Matthias Richter. Based on work by ioxu, Fabien Sanglard, Kenny Mitchell and Jason Mitchell.
* sketch.lua: Martin Felis, Matthias Richter
* fog.lua: Brandon Blanker Lim-it. Based on work by Gonkee.

================
File: lib/moonshine/scanlines.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern number width;
    extern number phase;
    extern number thickness;
    extern number opacity;
    extern vec3 color;
    vec4 effect(vec4 c, Image tex, vec2 tc, vec2 _) {
      number v = .5*(sin(tc.y * 3.14159 / width * love_ScreenSize.y + phase) + 1.);
      c = Texel(tex,tc);
      //c.rgb = mix(color, c.rgb, mix(1, pow(v, thickness), opacity));
      c.rgb -= (color - c.rgb) * (pow(v,thickness) - 1.0) * opacity;
      return c;
    }]]


  local defaults = {
    width = 2,
    phase = 0,
    thickness = 1,
    opacity = 1,
    color = {0,0,0},
  }

  local setters = {}
  setters.width = function(v)
    shader:send("width", tonumber(v) or defaults.width)
  end
  setters.frequency = function(v)
    shader:send("width", love.graphics.getHeight()/(tonumber(v) or love.graphics.getHeight()))
  end
  setters.phase = function(v)
    shader:send("phase", tonumber(v) or defaults.phase)
  end
  setters.thickness = function(v)
    shader:send("thickness", math.max(0, tonumber(v) or defaults.thickness))
  end
  setters.opacity = function(v)
    shader:send("opacity", math.min(1, math.max(0, tonumber(v) or defaults.opacity)))
  end
  setters.color = function(c)
    assert(type(c) == "table" and #c == 3, "Invalid value for `color'")
    shader:send("color", {
      (tonumber(c[1]) or defaults.color[0]) / 255,
      (tonumber(c[2]) or defaults.color[1]) / 255,
      (tonumber(c[3]) or defaults.color[2]) / 255
    })
  end

  return moonshine.Effect{
    name = "scanlines",
    shader = shader,
    setters = setters,
    defaults = defaults,
  }
end

================
File: lib/moonshine/sketch.lua
================
--[[
The MIT License (MIT)

Copyright (c) 2015 Martin Felis
Copyright (c) 2017 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]--

return function(moonshine)
  local noisetex = love.image.newImageData(256,256)
  noisetex:mapPixel(function()
    return love.math.random() * 255,love.math.random() * 255, 0, 0
  end)
  noisetex = love.graphics.newImage(noisetex)
  noisetex:setWrap ("repeat", "repeat")
  noisetex:setFilter("nearest", "nearest")

  local shader = love.graphics.newShader[[
    extern Image noisetex;
    extern number amp;
    extern vec2 center;

    vec4 effect(vec4 color, Image texture, vec2 tc, vec2 _) {
      vec2 displacement = Texel(noisetex, tc + center).rg;
      tc += normalize(displacement * 2.0 - vec2(1.0)) * amp;

      return Texel(texture, tc);
    }]]

  shader:send("noisetex", noisetex)

  local setters = {}
  setters.amp = function(v)
    shader:send("amp", math.max(0, tonumber(v) or 0))
  end
  setters.center = function(v)
    assert(type(v) == "table" and #v == 2, "Invalid value for `center'")
    shader:send("center", v)
  end

  return moonshine.Effect{
    name = "sketch",
    shader = shader,
    setters = setters,
    defaults = {amp = .0007, center = {0,0}}
  }
end

================
File: lib/moonshine/vignette.lua
================
--[[
Public domain:

Copyright (C) 2017 by Matthias Richter <vrld@vrld.org>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
]]--

return function(moonshine)
  local shader = love.graphics.newShader[[
    extern number radius;
    extern number softness;
    extern number opacity;
    extern vec4 color;

    vec4 effect(vec4 c, Image tex, vec2 tc, vec2 _)
    {
      number aspect = love_ScreenSize.x / love_ScreenSize.y;
      aspect = max(aspect, 1.0 / aspect); // use different aspect when in portrait mode
      number v = 1.0 - smoothstep(radius, radius-softness,
                                  length((tc - vec2(0.5)) * aspect));
      return mix(Texel(tex, tc), color, v*opacity);
    }]]

  local setters = {}
  for _,k in ipairs{"radius", "softness", "opacity"} do
    setters[k] = function(v) shader:send(k, math.max(0, tonumber(v) or 0)) end
  end
  setters.color = function(c)
    assert(type(c) == "table" and #c == 3, "Invalid value for `color'")
    shader:send("color", {
      (tonumber(c[1]) or 0) / 255,
      (tonumber(c[2]) or 0) / 255,
      (tonumber(c[3]) or 0) / 255,
      1
    })
  end

  return moonshine.Effect{
    name = "vignette",
    shader = shader,
    setters = setters,
    defaults = {
      radius = .8,
      softness = .5,
      opacity = .5,
      color = {0,0,0}
    }
  }
end

================
File: lib/tween.lua
================
local tween = {
    _VERSION     = 'tween 2.1.1',
    _DESCRIPTION = 'tweening for lua',
    _URL         = 'https://github.com/kikito/tween.lua',
    _LICENSE     = [[
      MIT LICENSE

      Copyright (c) 2014 Enrique Garc√≠a Cota, Yuichi Tateno, Emmanuel Oga

      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:

      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
}

-- easing

-- Adapted from https://github.com/EmmanuelOga/easing. See LICENSE.txt for credits.
-- For all easing functions:
-- t = time == how much time has to pass for the tweening to complete
-- b = begin == starting property value
-- c = change == ending - beginning
-- d = duration == running time. How much time has passed *right now*

local pow, sin, cos, pi, sqrt, abs, asin = math.pow, math.sin, math.cos, math.pi, math.sqrt, math.abs, math.asin

-- linear
local function linear(t, b, c, d) return c * t / d + b end

-- quad
local function inQuad(t, b, c, d) return c * pow(t / d, 2) + b end
local function outQuad(t, b, c, d)
    t = t / d
    return -c * t * (t - 2) + b
end
local function inOutQuad(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * pow(t, 2) + b end
    return -c / 2 * ((t - 1) * (t - 3) - 1) + b
end
local function outInQuad(t, b, c, d)
    if t < d / 2 then return outQuad(t * 2, b, c / 2, d) end
    return inQuad((t * 2) - d, b + c / 2, c / 2, d)
end

-- cubic
local function inCubic(t, b, c, d) return c * pow(t / d, 3) + b end
local function outCubic(t, b, c, d) return c * (pow(t / d - 1, 3) + 1) + b end
local function inOutCubic(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * t * t * t + b end
    t = t - 2
    return c / 2 * (t * t * t + 2) + b
end
local function outInCubic(t, b, c, d)
    if t < d / 2 then return outCubic(t * 2, b, c / 2, d) end
    return inCubic((t * 2) - d, b + c / 2, c / 2, d)
end

-- quart
local function inQuart(t, b, c, d) return c * pow(t / d, 4) + b end
local function outQuart(t, b, c, d) return -c * (pow(t / d - 1, 4) - 1) + b end
local function inOutQuart(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * pow(t, 4) + b end
    return -c / 2 * (pow(t - 2, 4) - 2) + b
end
local function outInQuart(t, b, c, d)
    if t < d / 2 then return outQuart(t * 2, b, c / 2, d) end
    return inQuart((t * 2) - d, b + c / 2, c / 2, d)
end

-- quint
local function inQuint(t, b, c, d) return c * pow(t / d, 5) + b end
local function outQuint(t, b, c, d) return c * (pow(t / d - 1, 5) + 1) + b end
local function inOutQuint(t, b, c, d)
    t = t / d * 2
    if t < 1 then return c / 2 * pow(t, 5) + b end
    return c / 2 * (pow(t - 2, 5) + 2) + b
end
local function outInQuint(t, b, c, d)
    if t < d / 2 then return outQuint(t * 2, b, c / 2, d) end
    return inQuint((t * 2) - d, b + c / 2, c / 2, d)
end

-- sine
local function inSine(t, b, c, d) return -c * cos(t / d * (pi / 2)) + c + b end
local function outSine(t, b, c, d) return c * sin(t / d * (pi / 2)) + b end
local function inOutSine(t, b, c, d) return -c / 2 * (cos(pi * t / d) - 1) + b end
local function outInSine(t, b, c, d)
    if t < d / 2 then return outSine(t * 2, b, c / 2, d) end
    return inSine((t * 2) - d, b + c / 2, c / 2, d)
end

-- expo
local function inExpo(t, b, c, d)
    if t == 0 then return b end
    return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
end
local function outExpo(t, b, c, d)
    if t == d then return b + c end
    return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
end
local function inOutExpo(t, b, c, d)
    if t == 0 then return b end
    if t == d then return b + c end
    t = t / d * 2
    if t < 1 then return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005 end
    return c / 2 * 1.0005 * (-pow(2, -10 * (t - 1)) + 2) + b
end
local function outInExpo(t, b, c, d)
    if t < d / 2 then return outExpo(t * 2, b, c / 2, d) end
    return inExpo((t * 2) - d, b + c / 2, c / 2, d)
end

-- circ
local function inCirc(t, b, c, d) return (-c * (sqrt(1 - pow(t / d, 2)) - 1) + b) end
local function outCirc(t, b, c, d) return (c * sqrt(1 - pow(t / d - 1, 2)) + b) end
local function inOutCirc(t, b, c, d)
    t = t / d * 2
    if t < 1 then return -c / 2 * (sqrt(1 - t * t) - 1) + b end
    t = t - 2
    return c / 2 * (sqrt(1 - t * t) + 1) + b
end
local function outInCirc(t, b, c, d)
    if t < d / 2 then return outCirc(t * 2, b, c / 2, d) end
    return inCirc((t * 2) - d, b + c / 2, c / 2, d)
end

-- elastic
local function calculatePAS(p, a, c, d)
    p, a = p or d * 0.3, a or 0
    if a < abs(c) then return p, c, p / 4 end -- p, a, s
    return p, a, p / (2 * pi) * asin(c / a)   -- p,a,s
end
local function inElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d
    if t == 1 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    t = t - 1
    return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end
local function outElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d
    if t == 1 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end
local function inOutElastic(t, b, c, d, a, p)
    local s
    if t == 0 then return b end
    t = t / d * 2
    if t == 2 then return b + c end
    p, a, s = calculatePAS(p, a, c, d)
    t = t - 1
    if t < 0 then return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b end
    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) * 0.5 + c + b
end
local function outInElastic(t, b, c, d, a, p)
    if t < d / 2 then return outElastic(t * 2, b, c / 2, d, a, p) end
    return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
end

-- back
local function inBack(t, b, c, d, s)
    s = s or 1.70158
    t = t / d
    return c * t * t * ((s + 1) * t - s) + b
end
local function outBack(t, b, c, d, s)
    s = s or 1.70158
    t = t / d - 1
    return c * (t * t * ((s + 1) * t + s) + 1) + b
end
local function inOutBack(t, b, c, d, s)
    s = (s or 1.70158) * 1.525
    t = t / d * 2
    if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
    t = t - 2
    return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
end
local function outInBack(t, b, c, d, s)
    if t < d / 2 then return outBack(t * 2, b, c / 2, d, s) end
    return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
end

-- bounce
local function outBounce(t, b, c, d)
    t = t / d
    if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end
    if t < 2 / 2.75 then
        t = t - (1.5 / 2.75)
        return c * (7.5625 * t * t + 0.75) + b
    elseif t < 2.5 / 2.75 then
        t = t - (2.25 / 2.75)
        return c * (7.5625 * t * t + 0.9375) + b
    end
    t = t - (2.625 / 2.75)
    return c * (7.5625 * t * t + 0.984375) + b
end
local function inBounce(t, b, c, d) return c - outBounce(d - t, 0, c, d) + b end
local function inOutBounce(t, b, c, d)
    if t < d / 2 then return inBounce(t * 2, 0, c, d) * 0.5 + b end
    return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
end
local function outInBounce(t, b, c, d)
    if t < d / 2 then return outBounce(t * 2, b, c / 2, d) end
    return inBounce((t * 2) - d, b + c / 2, c / 2, d)
end

tween.easing = {
    linear = linear,
    inQuad = inQuad,
    outQuad = outQuad,
    inOutQuad = inOutQuad,
    outInQuad = outInQuad,
    inCubic = inCubic,
    outCubic = outCubic,
    inOutCubic = inOutCubic,
    outInCubic = outInCubic,
    inQuart = inQuart,
    outQuart = outQuart,
    inOutQuart = inOutQuart,
    outInQuart = outInQuart,
    inQuint = inQuint,
    outQuint = outQuint,
    inOutQuint = inOutQuint,
    outInQuint = outInQuint,
    inSine = inSine,
    outSine = outSine,
    inOutSine = inOutSine,
    outInSine = outInSine,
    inExpo = inExpo,
    outExpo = outExpo,
    inOutExpo = inOutExpo,
    outInExpo = outInExpo,
    inCirc = inCirc,
    outCirc = outCirc,
    inOutCirc = inOutCirc,
    outInCirc = outInCirc,
    inElastic = inElastic,
    outElastic = outElastic,
    inOutElastic = inOutElastic,
    outInElastic = outInElastic,
    inBack = inBack,
    outBack = outBack,
    inOutBack = inOutBack,
    outInBack = outInBack,
    inBounce = inBounce,
    outBounce = outBounce,
    inOutBounce = inOutBounce,
    outInBounce = outInBounce
}



-- private stuff

local function copyTables(destination, keysTable, valuesTable)
    valuesTable = valuesTable or keysTable
    local mt = getmetatable(keysTable)
    if mt and getmetatable(destination) == nil then
        setmetatable(destination, mt)
    end
    for k, v in pairs(keysTable) do
        if type(v) == 'table' then
            destination[k] = copyTables({}, v, valuesTable[k])
        else
            destination[k] = valuesTable[k]
        end
    end
    return destination
end

local function checkSubjectAndTargetRecursively(subject, target, path)
    path = path or {}
    local targetType, newPath
    for k, targetValue in pairs(target) do
        targetType, newPath = type(targetValue), copyTables({}, path)
        table.insert(newPath, tostring(k))
        if targetType == 'number' then
            assert(type(subject[k]) == 'number',
                "Parameter '" .. table.concat(newPath, '/') .. "' is missing from subject or isn't a number")
        elseif targetType == 'table' then
            checkSubjectAndTargetRecursively(subject[k], targetValue, newPath)
        else
            assert(targetType == 'number',
                "Parameter '" .. table.concat(newPath, '/') .. "' must be a number or table of numbers")
        end
    end
end

local function checkNewParams(duration, subject, target, easing)
    assert(type(duration) == 'number' and duration > 0, "duration must be a positive number. Was " .. tostring(duration))
    local tsubject = type(subject)
    assert(tsubject == 'table' or tsubject == 'userdata',
        "subject must be a table or userdata. Was " .. tostring(subject))
    assert(type(target) == 'table', "target must be a table. Was " .. tostring(target))
    assert(type(easing) == 'function', "easing must be a function. Was " .. tostring(easing))
    checkSubjectAndTargetRecursively(subject, target)
end

local function getEasingFunction(easing)
    easing = easing or "linear"
    if type(easing) == 'string' then
        local name = easing
        easing = tween.easing[name]
        if type(easing) ~= 'function' then
            error("The easing function name '" .. name .. "' is invalid")
        end
    end
    return easing
end

local function performEasingOnSubject(subject, target, initial, clock, duration, easing)
    local t, b, c, d
    for k, v in pairs(target) do
        if type(v) == 'table' then
            performEasingOnSubject(subject[k], v, initial[k], clock, duration, easing)
        else
            t, b, c, d = clock, initial[k], v - initial[k], duration
            subject[k] = easing(t, b, c, d)
        end
    end
end

-- Tween methods

local Tween = {}
local Tween_mt = { __index = Tween }

function Tween:set(clock)
    assert(type(clock) == 'number', "clock must be a positive number or 0")

    self.initial = self.initial or copyTables({}, self.target, self.subject)
    self.clock = clock

    if self.clock <= 0 then
        self.clock = 0
        copyTables(self.subject, self.initial)
    elseif self.clock >= self.duration then -- the tween has expired
        self.clock = self.duration
        copyTables(self.subject, self.target)
    else
        performEasingOnSubject(self.subject, self.target, self.initial, self.clock, self.duration, self.easing)
    end

    return self.clock >= self.duration
end

function Tween:reset()
    return self:set(0)
end

function Tween:update(dt)
    assert(type(dt) == 'number', "dt must be a number")
    return self:set(self.clock + dt)
end

-- Public interface

function tween.new(duration, subject, target, easing)
    easing = getEasingFunction(easing)
    checkNewParams(duration, subject, target, easing)
    return setmetatable({
        duration = duration,
        subject  = subject,
        target   = target,
        easing   = easing,
        clock    = 0
    }, Tween_mt)
end

return tween

================
File: lib/vector.lua
================
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]] --

local assert = assert
local sqrt, cos, sin, atan2 = math.sqrt, math.cos, math.sin, math.atan2

local vector = {}
vector.__index = vector

local function new(x, y)
    return setmetatable({ x = x or 0, y = y or 0 }, vector)
end
local zero = new(0, 0)

local function fromPolar(angle, radius)
    radius = radius or 1
    return new(cos(angle) * radius, sin(angle) * radius)
end

local function randomDirection(len_min, len_max)
    len_min = len_min or 1
    len_max = len_max or len_min

    assert(len_max > 0, "len_max must be greater than zero")
    assert(len_max >= len_min, "len_max must be greater than or equal to len_min")

    return fromPolar(math.random() * 2 * math.pi,
        math.random() * (len_max - len_min) + len_min)
end

local function isvector(v)
    return type(v) == 'table' and type(v.x) == 'number' and type(v.y) == 'number'
end

function vector:clone()
    return new(self.x, self.y)
end

function vector:unpack()
    return self.x, self.y
end

function vector:__tostring()
    return "(" .. tonumber(self.x) .. "," .. tonumber(self.y) .. ")"
end

function vector.__unm(a)
    return new(-a.x, -a.y)
end

function vector.__add(a, b)
    assert(isvector(a) and isvector(b), "Add: wrong argument types (<vector> expected)")
    return new(a.x + b.x, a.y + b.y)
end

function vector.__sub(a, b)
    assert(isvector(a) and isvector(b), "Sub: wrong argument types (<vector> expected)")
    return new(a.x - b.x, a.y - b.y)
end

function vector.__mul(a, b)
    if type(a) == "number" then
        return new(a * b.x, a * b.y)
    elseif type(b) == "number" then
        return new(b * a.x, b * a.y)
    else
        assert(isvector(a) and isvector(b), "Mul: wrong argument types (<vector> or <number> expected)")
        return a.x * b.x + a.y * b.y
    end
end

function vector.__div(a, b)
    assert(isvector(a) and type(b) == "number", "wrong argument types (expected <vector> / <number>)")
    return new(a.x / b, a.y / b)
end

function vector.__eq(a, b)
    return a.x == b.x and a.y == b.y
end

function vector.__lt(a, b)
    return a.x < b.x or (a.x == b.x and a.y < b.y)
end

function vector.__le(a, b)
    return a.x <= b.x and a.y <= b.y
end

function vector.permul(a, b)
    assert(isvector(a) and isvector(b), "permul: wrong argument types (<vector> expected)")
    return new(a.x * b.x, a.y * b.y)
end

function vector:toPolar()
    return new(atan2(self.x, self.y), self:len())
end

function vector:len2()
    return self.x * self.x + self.y * self.y
end

function vector:len()
    return sqrt(self.x * self.x + self.y * self.y)
end

function vector.dist(a, b)
    assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
    local dx = a.x - b.x
    local dy = a.y - b.y
    return sqrt(dx * dx + dy * dy)
end

function vector.dist2(a, b)
    assert(isvector(a) and isvector(b), "dist: wrong argument types (<vector> expected)")
    local dx = a.x - b.x
    local dy = a.y - b.y
    return (dx * dx + dy * dy)
end

function vector:normalizeInplace()
    local l = self:len()
    if l > 0 then
        self.x, self.y = self.x / l, self.y / l
    end
    return self
end

function vector:normalized()
    return self:clone():normalizeInplace()
end

function vector:rotateInplace(phi)
    local c, s = cos(phi), sin(phi)
    self.x, self.y = c * self.x - s * self.y, s * self.x + c * self.y
    return self
end

function vector:rotated(phi)
    local c, s = cos(phi), sin(phi)
    return new(c * self.x - s * self.y, s * self.x + c * self.y)
end

function vector:perpendicular()
    return new(-self.y, self.x)
end

function vector:projectOn(v)
    assert(isvector(v), "invalid argument: cannot project vector on " .. type(v))
    -- (self * v) * v / v:len2()
    local s = (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
    return new(s * v.x, s * v.y)
end

function vector:mirrorOn(v)
    assert(isvector(v), "invalid argument: cannot mirror vector on " .. type(v))
    -- 2 * self:projectOn(v) - self
    local s = 2 * (self.x * v.x + self.y * v.y) / (v.x * v.x + v.y * v.y)
    return new(s * v.x - self.x, s * v.y - self.y)
end

function vector:cross(v)
    assert(isvector(v), "cross: wrong argument types (<vector> expected)")
    return self.x * v.y - self.y * v.x
end

-- ref.: http://blog.signalsondisplay.com/?p=336
function vector:trimInplace(maxLen)
    local s = maxLen * maxLen / self:len2()
    s = (s > 1 and 1) or math.sqrt(s)
    self.x, self.y = self.x * s, self.y * s
    return self
end

function vector:angleTo(other)
    if other then
        return atan2(self.y, self.x) - atan2(other.y, other.x)
    end
    return atan2(self.y, self.x)
end

function vector:trimmed(maxLen)
    return self:clone():trimInplace(maxLen)
end

-- the module
return setmetatable({
    new             = new,
    fromPolar       = fromPolar,
    randomDirection = randomDirection,
    isvector        = isvector,
    zero            = zero
}, {
    __call = function(_, ...) return new(...) end
})

================
File: LICENSE.md
================
Copyright 2025 Quoc Bao

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: main.lua
================
local moonshine         = require("lib.moonshine")
local sceneManager      = require("src.managers.scene_manager")
local consts            = require("src.globals.consts")
local res               = require("src.globals.res")
local file              = require("src.utils.file")
local input             = require("src.utils.input")

--#region Debugger setup

local love_errorhandler = love.errorhandler
-- Enables code debugger via launch.json
if arg[2] == "debug" then
    require("lldebugger").start()
end

-- Tell Love to throw an error instead of showing it on screen
function love.errorhandler(msg)
    if lldebugger then
        error(msg, 2)
    else
        return love_errorhandler(msg)
    end
end

--#endregion

local assets        = {} -- Shared assets
local configs       = {} -- Game configs
local scanlinesTime = 0  -- Scanlines delta time

function love.load()
    love.graphics.setDefaultFilter("nearest", "nearest")
    -- Set game title and icon
    local gameIcon = love.image.newImageData(res.GAME_ICON)
    love.window.setIcon(gameIcon)
    love.window.setTitle(consts.GAME_TITLE)

    -- === Load sprites ===
    assets.tileset = love.graphics.newImage(res.TILESET)

    -- === Load sounds ===
    assets.titleSound = love.audio.newSource(res.EDIT_SOUND, "stream")
    assets.titleSound:setLooping(true)
    assets.titleSound:setVolume(0.5)

    assets.bgSound = love.audio.newSource(res.MAIN_SOUND, "stream")
    assets.bgSound:setLooping(true)
    assets.bgSound:setVolume(0.5)

    assets.clickSound = love.audio.newSource(res.CLICK_SOUND, "static")
    assets.clickSound:setVolume(0.5)

    -- === Load shaders ===
    assets.glowShader = moonshine(moonshine.effects.glow)
    assets.sclShader = moonshine(moonshine.effects.scanlines)
    assets.sclShader.scanlines.thickness = 0.1

    -- Load configs and start game
    configs = file.loadConfigs()
    sceneManager:load(assets, configs)
end

function love.keypressed(key)
    input:keypressed(key)
end

function love.keyreleased(key)
    input:keyreleased(key)
end

function love.mousemoved(x, y, dx, dy, isTouch)
    -- Ignore small movements
    local min = 2
    if math.abs(dx) < min and math.abs(dy) < min then return end

    sceneManager:mousemoved(x, y, dx, dy, isTouch)
end

function love.mousepressed(x, y, btn, isTouch, presses)
    sceneManager:mousepressed(x, y, btn, isTouch, presses)
end

function love.mousereleased(x, y, btn, isTouch, presses)
    sceneManager:mousereleased(x, y, btn, isTouch, presses)
end

function love.update(dt)
    scanlinesTime = scanlinesTime + dt * 40
    assets.sclShader.scanlines.phase = scanlinesTime

    sceneManager:update(dt)
    input:update()
end

-- Draw game screen with scanlines
function love.draw()
    assets.sclShader(function()
        sceneManager:draw()
    end)
end

================
File: README.md
================
# NE√ñN

In NE√ñN, you‚Äôre a lone runner hurtling through a glowing tunnel of chaos. Your mission? Survive the surge, collect energy orbs, and dodge deadly obstacles by jumping left or right at hyperspeed.

Powered by [moonshine](https://github.com/vrld/moonshine) shaders, the world of NE√ñN pulses with life ‚Äî bloom, blur, and distortion effects react to your every move. Crank up your reflexes and ride the light.

Made with L√ñVE‚Ñ¢.

## Player Manual

1. Control: `Space` or `Left Mouse Button` to jump
2. Menu: `Tab` or `Up` and `Down` to navigate menu
3. Action: `Space` or `Enter` to pause/resume or restart, `Esc` to go back

## Building

### Dependencies

Before you begin, make sure you have the following installed:

- Lua 5.1 or higher
- Love2D
- Python 3

After you have Python installed on your system, add these following packages for building cross-platforms:

```sh
pip3 install setuptools
pip3 install makelove
```

### Installation

Clone the repository:

```sh
git clone https://github.com/baolhq/neon.git
cd neon && code .
```

Then run this command to build

```sh
makelove --config build_config.toml
```

## Executing

To build and run the project:

- Press `Ctrl+Shift+B` to build using the provided `build_config.toml`, this will generate executables at `/bin` directory
- Or skip to run the project simply with `F5`

## Project Structure

```sh
/neon
‚îú‚îÄ‚îÄ main.lua                # Entry point
‚îú‚îÄ‚îÄ conf.lua                # Startup configurations
‚îú‚îÄ‚îÄ build_config.toml       # Setup for cross-platforms building
‚îú‚îÄ‚îÄ /.vscode                # VSCode launch, debug and build setup
‚îú‚îÄ‚îÄ /lib                    # Third-party libraries
‚îú‚îÄ‚îÄ /res                    # Static resources
‚îú‚îÄ‚îÄ /src                    # Game source code
‚îÇ   ‚îú‚îÄ‚îÄ models/             # Game entities
‚îÇ   ‚îú‚îÄ‚îÄ globals/            # Global variables
‚îÇ   ‚îú‚îÄ‚îÄ managers/           # Manage screens, inputs, game states etc..
‚îÇ   ‚îú‚îÄ‚îÄ scenes/             # Game scenes
‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Helper functions
‚îî‚îÄ‚îÄ /bin                    # Build output
```

## License

This project is licensed under the [MIT License](LICENSE.md). Feel free to customize it whatever you want.

================
File: src/globals/colors.lua
================
-- === Game color palette ===
return {
    WHITE = { 1.0, 1.0, 1.0 },
    BLACK = { 0.1, 0.1, 0.1 },
    RED = { 0.6, 0.2, 0.2 },
    SLATE_100 = { 0.1, 0.1, 0.1 },
    SLATE_200 = { 0.2, 0.2, 0.2 },
    SLATE_300 = { 0.3, 0.3, 0.3 },
    SLATE_400 = { 0.4, 0.4, 0.4 },
    SLATE_600 = { 0.6, 0.6, 0.6 },
    SLATE_800 = { 0.8, 0.8, 0.8 },
}

================
File: src/globals/consts.lua
================
-- === Global constants ===
return {
    GAME_TITLE = "NE√ñN",
    WINDOW_W = 800,
    WINDOW_H = 600,
    GROUND_H = 50,
    FONT_TITLE_SIZE = 80,
    FONT_HEADER_SIZE = 48,
    FONT_SUB_SIZE = 16,
}

================
File: src/globals/res.lua
================
-- === Game resource paths ===
return {
    -- Images
    GAME_ICON = "res/img/icon.png",
    TILESET = "res/img/tileset.png",
    PARTICLE = "res/img/rectangle.png",

    -- Sounds
    EDIT_SOUND = "res/audio/edit_theme.mp3",
    MAIN_SOUND = "res/audio/main_theme.mp3",
    CLICK_SOUND = "res/audio/click.wav",

    -- Fonts
    MAIN_FONT = "res/fonts/Retro_Gaming.ttf",

    -- File paths
    CONFIG_PATH = "neon.conf",
    SAVE_PATH = "scores.txt",
}

================
File: src/managers/scene_manager.lua
================
local tween        = require("lib.tween")
local colors       = require("src.globals.colors")

local sceneManager = {}

-- === Game scenes ===
local scenes       = {
    title = require("src.scenes.title_scene"),
    main = require("src.scenes.main_scene"),
    lboard = require("src.scenes.lboard_scene"),
    settings = require("src.scenes.settings_scene"),
}

function sceneManager:load(assets, configs)
    self.assets        = assets
    self.configs       = configs
    self.current       = "title"
    self.next          = nil
    self.transitioning = false
    self.coverX        = nil -- For black rectangle
    self.stage         = nil -- 'in' -> switch -> 'out'
    self.tween         = nil
    self.actions       = {
        switchScene = function(newScene)
            self:switch(newScene)
        end,
        quit = function() love.event.quit() end
    }

    -- Don't use transition on initial load
    scenes[self.current]:load(self.assets, self.actions, self.configs)
end

function sceneManager:switch(name)
    if self.transitioning then return end

    self.transitioning = true
    self.next = name
    self.coverX = love.graphics.getWidth()
    self.stage = "in"

    self.tween = tween.new(0.4, self, { coverX = 0 }, "outQuad")
end

function sceneManager:mousemoved(x, y, dx, dy, isTouch)
    if scenes[self.current].mousemoved then
        scenes[self.current]:mousemoved(x, y, dx, dy, isTouch)
    end
end

function sceneManager:mousepressed(x, y, btn, isTouch, presses)
    if scenes[self.current].mousepressed then
        scenes[self.current]:mousepressed(x, y, btn, isTouch, presses)
    end
end

function sceneManager:mousereleased(x, y, btn, isTouch, presses)
    if scenes[self.current].mousereleased then
        scenes[self.current]:mousereleased(x, y, btn, isTouch, presses)
    end
end

function sceneManager:update(dt)
    if self.transitioning and self.tween then
        local complete = self.tween:update(dt)
        if complete then
            if self.stage == "in" then
                -- Now switch scenes under the black cover
                self.current = self.next
                scenes[self.current]:load(self.assets, self.actions, self.configs)

                -- Start swipe out
                self.stage = "out"
                self.coverX = 0
                self.tween = tween.new(0.4, self, { coverX = -love.graphics.getWidth() }, "inQuad")
            else
                -- Finished transition
                self.transitioning = false
                self.tween = nil
                self.stage = nil
                self.next = nil
                self.coverX = nil
            end
        end
    end

    if scenes[self.current].update then
        scenes[self.current]:update(dt)
    end
end

function sceneManager:draw()
    if scenes[self.current].draw then
        scenes[self.current]:draw()
    end

    -- Draw the curtain if in transition
    if self.transitioning and self.coverX then
        love.graphics.setColor(colors.SLATE_100)
        love.graphics.rectangle("fill", self.coverX, 0, love.graphics.getWidth(), love.graphics.getHeight())
    end
end

return sceneManager

================
File: src/models/enemy.lua
================
local anim8     = require("lib.anim8")
local vector    = require("lib.vector")
local colors    = require("src.globals.colors")
local consts    = require("src.globals.consts")

local enemy     = {}

-- === Constants ===
local POOL_SIZE = 20
local SCALE     = 2
local FRAME_W   = 16
local FRAME_H   = 16

-- === Pooling ===
local pool      = {}

-- === Pseudo Random ===
local ptCasual  = {
    "bbbtbtttbbtbtbbbttbt",
    "tbtbtttbtbbbttbbtbtt",
    "bbttbbtbttbbbtttbtbt",
    "ttbbtttbbtbtbttbbbtb",
    "btbttbbtbttbbbtbttbt",
    "tbbtbbtttbtbtbbtbttb",
    "bbtbtbttbbtttbbtbtbt",
    "ttbttbbtbbtbttbbtbtb",
    "bttbbtttbbbtbbtttbtb",
    "tbbttbbtbttbbtbtbbtt",
}
local ptHard    = {
    "bbbbttbbtttbbbbttbbt",
    "ttttbbtttbbbbttbbtbt",
    "bbbtttbbbbtttbbbtttb",
    "tttttbbbtbbttbbbtttb",
    "bbbttbbbbtttbtttbbtb",
    "ttttbbbtttbttbbbbttb",
    "bbtttbbbbttbbbtttbbt",
    "tttbbbttttbbttbbbttb",
    "bbbbtttbbbtttbbbbttb",
    "tttbbbbtttbbbbtttbbt",
}

---Validate pattern length and randomness
---@param p table
local function validatePattern(p)
    assert(#p == POOL_SIZE, "Pattern length must be the same as POOL_SIZE")

    local count = 1
    for i = 2, #p do
        if p[i] == p[i + 1] then
            count = count + 1
            if count > 5 then
                error("Too many of the same side in a row: " .. p)
            end
        else
            count = 1
        end
    end
end

local function spawn(side, mode, anims)
    local e = {
        w = FRAME_W * SCALE,
        h = FRAME_H * SCALE,
        dead = false,
        baseAnim = anim8.newAnimation(anims("1-3", 2), 0.2),
        deathAnim = anim8.newAnimation(anims("4-4", 2), 1),
    }

    if mode == 1 then
        e.speed = 200
    elseif mode == 2 then
        e.speed = 300
    else
        e.speed = 400
    end

    local topY = consts.GROUND_H
    local botY = consts.WINDOW_H - consts.GROUND_H - e.h
    e.pos = vector(love.graphics.getWidth() + 100, 0)
    e.pos.y = side == "t" and topY or botY

    setmetatable(e, { __index = enemy })
    return e
end

local function createPool(mode, anims)
    local presets = {}
    if mode == 1 then
        presets = ptCasual
    elseif mode == 2 then
        presets = ptHard
    end

    local rand = love.math.random(1, #presets)
    local pattern = {}
    for i = 1, #presets[rand] do
        pattern[i] = presets[rand]:sub(i, i)
    end

    for i = 1, POOL_SIZE do
        table.insert(pool, spawn(pattern[i], mode, anims))
    end

    validatePattern(pattern)
end

function enemy.get(mode, anims)
    if #pool == 0 then createPool(mode, anims) end
    return table.remove(pool)
end

function enemy:update(dt)
    self.pos.x = self.pos.x - self.speed * dt
    self.baseAnim:update(dt)
end

function enemy:draw(tileset)
    love.graphics.setColor(colors.SLATE_800)

    local oX, oY = self.w / 2, self.h / 2
    local facingDir
    if self.pos.y + oY > consts.WINDOW_H / 2 then
        facingDir = 1
    else
        facingDir = -1
    end

    if self.dead then
        self.deathAnim:draw(
            tileset,
            self.pos.x + oX,
            -- Offset to fix visual
            self.pos.y + oY - 1 * facingDir,
            0,
            -- Scale up to match its collision box
            SCALE * 1.5, SCALE * facingDir * 1.5,
            FRAME_W / 2, FRAME_H / 2
        )
    else
        self.baseAnim:draw(
            tileset,
            self.pos.x + oX,
            -- Offset to fix visual
            self.pos.y + oY - 1 * facingDir,
            0,
            -- Scale up to match its collision box
            SCALE * 1.5, SCALE * facingDir * 1.5,
            FRAME_W / 2, FRAME_H / 2
        )
    end
end

return enemy

================
File: src/models/orb.lua
================
local orb = {}

function orb:init()

end

function orb:update(dt)

end

function orb:draw()

end

return orb

================
File: src/models/player.lua
================
local anim8       = require("lib.anim8")
local vector      = require("lib.vector")
local colors      = require("src.globals.colors")
local consts      = require("src.globals.consts")
local collider    = require("src.utils.collider")

-- === Constants ===
local GRAVITY     = 1200
local STR_GRAVITY = 3600 -- Stronger gravity if not holding jump

local player      = {}

function player:init(anims)
    self.anim        = anim8.newAnimation(anims("1-4", 1), 0.1)
    self.w, self.h   = 48, 48
    self.lane        = 2 -- 1=top, 2=bottom
    self.maxJumps    = 2
    self.jumpsLeft   = self.maxJumps
    self.holdingJump = false
    self.velY        = 0    -- Current Y-axis velocity
    self.prevY       = 0    -- Store preivous Y-axis location
    self.impulse     = -650 -- How high the jump
    self.pos         = vector(
        consts.WINDOW_W * 0.2,
        consts.WINDOW_H - consts.GROUND_H - self.w
    )
end

-- === Behavior ===
function player:update(dt)
    self.prevY = self.pos.y

    -- Apply gravity
    local gravity = self.holdingJump and GRAVITY or STR_GRAVITY
    local gravityDir = self.lane == 1 and -1 or 1
    self.velY = self.velY + gravity * gravityDir * dt
    self.pos.y = self.pos.y + self.velY * dt

    -- If player crosses the middle of the screen, flip the lane
    local midY = consts.WINDOW_H / 2
    local curY = self.pos.y + self.h / 2
    if (self.prevY + self.h / 2 < midY and curY >= midY) or
        (self.prevY + self.h / 2 > midY and curY <= midY)
    then
        self.lane = 3 - self.lane
    end

    local topY = consts.GROUND_H
    local botY = consts.WINDOW_H - consts.GROUND_H
    local landed = false

    -- Snap to the ground when landed
    if self.pos.y <= topY then
        self.pos.y = topY
        self.velY = 0
        landed = true
    elseif self.pos.y + self.h >= botY then
        self.pos.y = botY - self.h
        self.velY = 0
        landed = true
    end

    -- Reset jump and stop movement if landed
    if landed then
        self.jumpsLeft = self.maxJumps
        self.anim:update(dt)
    end
end

-- Begin the jump, if keep calling, the player will
-- gradually falls off
function player:jumpStart()
    if self.jumpsLeft <= 0 then return end

    self.holdingJump = true
    self.jumpsLeft = self.jumpsLeft - 1
    self.velY = self.lane == 1 and -self.impulse or self.impulse
end

-- Release the jump, gravity pull stronger
function player:jumpEnd()
    self.holdingJump = false
end

-- Check if the player is landing on top of an enemy's head
function player:checkOnTop(enemy)
    local gravityDir = self.lane == 1 and -1 or 1

    -- Player bottom or top depending on gravity
    local pEdge = self.lane == 1 and self.pos.y or (self.pos.y + self.h)
    local pPrevEdge = self.lane == 1 and self.prevY or (self.prevY + self.h)
    local eEdge = self.lane == 1 and (enemy.pos.y + enemy.h) or enemy.pos.y

    -- Check horizontal overlap
    local pLeft = self.pos.x
    local pRight = self.pos.x + self.w
    local eLeft = enemy.pos.x
    local eRight = enemy.pos.x + enemy.w
    local hOverlap = pRight > eLeft and pLeft < eRight

    -- Check if player moved past enemy edge in direction of gravity
    local vOverlap = gravityDir > 0
        and pPrevEdge <= eEdge and pEdge >= eEdge
        or pPrevEdge >= eEdge and pEdge <= eEdge

    return hOverlap and vOverlap
end

function player:checkCollision(enemies)
    local target = nil
    for _, e in ipairs(enemies) do
        if not e.dead and collider.aabb(self, e) then
            target = e
            break
        end
    end
    return target
end

function player:draw(tileset)
    love.graphics.setColor(colors.SLATE_800)

    local oX, oY = self.w / 2, self.h / 2
    local facingDir
    if self.pos.y + oY > consts.WINDOW_H / 2 then
        facingDir = 1
    else
        facingDir = -1
    end

    self.anim:draw(
        tileset,
        self.pos.x + oX,
        self.pos.y + oY + 8 * facingDir,
        0,
        3, 3 * facingDir,
        8, 8
    )
end

return player

================
File: src/scenes/lboard_scene.lua
================
local colors      = require("src.globals.colors")
local input       = require("src.utils.input")

local lboardScene = {}

function lboardScene:load(assets, actions, configs)
    self.assets  = assets
    self.actions = actions
    self.configs = configs
end

function lboardScene:handleInputs()
    if input:wasPressed("back") then
        self.actions.switchScene("title")
    end
end

function lboardScene:update(dt)
    self:handleInputs()
end

function lboardScene:draw()
    love.graphics.clear(colors.SLATE_100)
end

return lboardScene

================
File: src/scenes/main_scene.lua
================
local anim8           = require("lib.anim8")
local moonshine       = require("lib.moonshine")
local colors          = require("src.globals.colors")
local consts          = require("src.globals.consts")
local res             = require("src.globals.res")
local drawer          = require("src.utils.drawer")
local file            = require("src.utils.file")
local input           = require("src.utils.input")

local player          = require("src.models.player")
local enemy           = require("src.models.enemy")

-- === Constants ===
local ENEMY_THRESHOLD = 0.6

local mainScene       = {}

function mainScene:load(assets, actions, configs)
    self.assets                     = assets
    self.actions                    = actions
    self.configs                    = configs
    self.enemies                    = {}
    self.eTimer                     = 0
    self.isPaused                   = false
    self.isGameOver                 = false

    -- === Scoring ===
    self.score                      = 0
    self.highScores                 = file.loadScores()
    self.scoreSaved                 = false

    -- === Shaders ===
    self.cmsShader                  = moonshine(moonshine.effects.chromasep)
    self.cmsShader.chromasep.radius = 4

    -- === Animations ===
    local tileW                     = self.assets.tileset:getWidth()
    local tileH                     = self.assets.tileset:getHeight()
    self.anims                      = anim8.newGrid(16, 16, tileW, tileH)

    player:init(self.anims)
end

function mainScene:reload()
    for i = #self.enemies, 1, -1 do
        table.remove(self.enemies, i)
    end
    self.enemies = {}

    self.isGameOver = false
    self.scoreSaved = false
    self.actions.switchScene("main")
end

function mainScene:handleInputs()
    if input:wasPressed("back") then
        self.actions.switchScene("title")
    end

    if not self.isGameOver and input:wasPressed("accept") then
        self.isPaused = not self.isPaused
    end

    if self.isGameOver and
        (input:wasPressed("accept") or input:wasPressed("jump"))
    then
        self:reload()
        return
    end

    if input:wasPressed("jump") then
        player:jumpStart()
    elseif input:wasReleased("jump") then
        player:jumpEnd()
    end
end

function mainScene:mousepressed(x, y, btn, isTouch, presses)
    if btn == 1 then
        if self.isGameOver then
            self:reload()
        else
            player:jumpStart()
        end
    end
end

function mainScene:mousereleased(x, y, btn, isTouch, presses)
    if btn == 1 then
        player:jumpEnd()
    end
end

function mainScene:update(dt)
    self:handleInputs()

    if self.isGameOver and not self.scoreSaved then
        table.insert(self.highScores, self.score)
        table.sort(self.highScores, function(a, b)
            return a > b
        end)

        while #self.highScores > 5 do
            table.remove(self.highScores)
        end
        file.saveScores(self.highScores)
        self.scoreSaved = true
    end

    if self.isPaused or self.isGameOver then return end

    -- Spawn enemies
    self.eTimer = self.eTimer + dt
    if self.eTimer > ENEMY_THRESHOLD then
        local m = tonumber(self.configs.mode) or 1
        local newObs = enemy.get(m, self.anims)
        table.insert(self.enemies, newObs)
        self.eTimer = 0
    end

    -- Update enemies
    for _, o in ipairs(self.enemies) do
        o:update(dt)
    end

    player:update(dt)
    local collided = player:checkCollision(self.enemies)
    if collided then
        local isOnTop = player:checkOnTop(collided)
        if not isOnTop then
            self.isGameOver = true
        else
            player.velY = player.lane == 2 and player.impulse or -player.impulse
            collided.dead = true
            self.score = self.score + 1
        end
    end
end

function mainScene:draw()
    self.cmsShader(function()
        love.graphics.clear(colors.SLATE_100)
        local w, h = love.graphics.getDimensions()

        -- === Draw lanes ===
        love.graphics.setColor(colors.SLATE_200)
        love.graphics.rectangle("fill", 0, 0, w, consts.GROUND_H)
        local groundBx = consts.WINDOW_H - consts.GROUND_H
        love.graphics.rectangle("fill", 0, groundBx, w, consts.GROUND_H)

        -- === Draw center line ===
        love.graphics.setColor(colors.SLATE_200)
        love.graphics.rectangle("line", 0, h / 2, w, 1)

        -- === Draw player ===
        player:draw(self.assets.tileset)

        -- === Draw enemies ===
        for _, e in ipairs(self.enemies) do
            e:draw(self.assets.tileset)
        end

        -- === Draw score ===
        local font = file:getFont(res.MAIN_FONT, consts.FONT_HEADER_SIZE)
        local scoreText = string.format("%02d", self.score)
        local scoreW, scoreH = font:getWidth(scoreText) + 16, font:getHeight()

        -- Draw score background
        love.graphics.setColor(colors.SLATE_100)
        love.graphics.rectangle(
            "fill",
            w / 2 - scoreW / 2,
            h / 2 - scoreH / 2,
            scoreW, scoreH
        )

        -- Draw score text
        love.graphics.setColor(colors.SLATE_200)
        drawer.drawCenteredText(scoreText, font, 0, 0)

        -- === Draw pause screen ===
        if self.isPaused then
            drawer.drawOverlay(140, "PAUSED", {
                { text = "PRESS START", y = 0 },
            })
        end

        -- === Draw game over screen ===
        if self.isGameOver then
            drawer.drawOverlay(140, "GAME OVER", {
                { text = "PRESS START", y = 0 },
            })
        end
    end)
end

return mainScene

================
File: src/scenes/settings_scene.lua
================
local colors        = require("src.globals.colors")
local consts        = require("src.globals.consts")
local res           = require("src.globals.res")
local drawer        = require("src.utils.drawer")
local file          = require("src.utils.file")
local input         = require("src.utils.input")

local settingsScene = {}

local focusedIndex  = 1
local buttonOrder   = { "music", "mode", "back" }
local buttons       = {
    music = {
        x = 0,
        y = 0,
        width = 200,
        height = 40,
        text = "MUSIC: ON",
        active = true,
        toggle = true,
        state = true, -- true = ON, false = OFF
    },
    mode = {
        x = 0,
        y = 0,
        width = 200,
        height = 40,
        text = "MODE: NORMAL",
        options = { "NORMAL", "HARD", "INSANE" },
        index = 1,
        active = false,
    },
    back = {
        x = 0,
        y = 0,
        width = 200,
        height = 40,
        text = "BACK",
        active = false,
    }
}

function settingsScene:load(assets, actions, configs)
    self.assets       = assets
    self.actions      = actions
    self.configs      = configs

    -- Draw buttons with spacings
    local spacingY    = 8
    local totalHeight = #buttonOrder * buttons.music.height + (#buttonOrder - 1) * spacingY
    local startY      = (love.graphics.getHeight() - totalHeight) / 2 + 88

    for i = 1, #buttonOrder do
        local button = buttons[buttonOrder[i]]
        button.x = (love.graphics.getWidth() - button.width) / 2
        button.y = startY + (i - 1) * (button.height + spacingY)
    end

    if configs.music then
        local state = configs.music == "true"
        buttons.music.state = state
        buttons.music.text = state and "MUSIC: ON" or "MUSIC: OFF"
    end

    if configs.mode then
        local id = tonumber(configs.mode)
        buttons.mode.index = id
        buttons.mode.text = "MODE: " .. buttons.mode.options[id]
    end
end

local function updateMusicBtn(btn, cfg)
    btn.state = not btn.state
    btn.text = "MUSIC: " .. (btn.state and "ON" or "OFF")
    cfg.music = btn.state
    file.saveConfigs(cfg)
end

local function updateModeBtn(btn, cfg)
    btn.index = btn.index % #btn.options + 1
    btn.text = "MODE: " .. btn.options[btn.index]
    cfg.mode = btn.index
    file.saveConfigs(cfg)
end

function settingsScene:handleInputs()
    if input:wasPressed("back") then
        self.actions.switchScene("title")
    end

    if input:wasPressed("accept") then
        if buttons.music.active then
            updateMusicBtn(buttons.music, self.configs)
        elseif buttons.mode.active then
            updateModeBtn(buttons.mode, self.configs)
        else
            self.actions.switchScene("title")
        end
    end

    -- Cycling through button focuses
    if input:wasPressed("tab") or
        input:wasPressed("up") or
        input:wasPressed("down")
    then
        -- Remove old focuses
        for _, b in pairs(buttons) do
            b.active = false
        end

        if input:wasPressed("up") then
            focusedIndex = (focusedIndex - 2) % #buttonOrder + 1
        else
            focusedIndex = focusedIndex % #buttonOrder + 1
        end

        buttons[buttonOrder[focusedIndex]].active = true
    end
end

function settingsScene:mousemoved(x, y, dx, dy, isTouch)
    local mx, my = love.mouse:getPosition()

    for _, b in pairs(buttons) do
        b.active =
            mx > b.x and mx < b.x + b.width and
            my > b.y and my < b.y + b.height
    end
end

function settingsScene:mousepressed(x, y, btn, isTouch, presses)
    self.assets.clickSound:play()
    if btn ~= 1 then return end -- left click only

    for name, b in pairs(buttons) do
        if b.active then
            if name == "music" and b.toggle then
                updateMusicBtn(b, self.configs)
            elseif name == "mode" and b.options then
                updateModeBtn(b, self.configs)
            elseif name == "back" then
                self.actions.switchScene("title")
            end
        end
    end
end

function settingsScene:update(dt)
    self:handleInputs()
end

function settingsScene:draw()
    love.graphics.clear(colors.SLATE_100)

    local font = file:getFont(res.MAIN_FONT, consts.FONT_HEADER_SIZE)
    drawer.drawCenteredText("SETTINGS", font, 0, -68)

    font = file:getFont(res.MAIN_FONT, consts.FONT_SUB_SIZE)
    for _, btn in pairs(buttons) do
        drawer.drawButton(btn, font)
    end
end

return settingsScene

================
File: src/scenes/title_scene.lua
================
local moonshine    = require("lib.moonshine")
local colors       = require("src.globals.colors")
local consts       = require("src.globals.consts")
local res          = require("src.globals.res")
local drawer       = require("src.utils.drawer")
local file         = require("src.utils.file")
local input        = require("src.utils.input")

local titleScene   = {}
local focusedIndex = 1
local buttonOrder  = { "start", "lboard", "settings" }
local buttons      = {
    start = {
        x = 0,
        y = 0,
        width = 200,
        height = 40,
        text = "START",
        active = true,
    },
    lboard = {
        x = 0,
        y = 0,
        width = 200,
        height = 40,
        text = "LEADERBOARD",
        active = false,
    },
    settings = {
        x = 0,
        y = 0,
        width = 200,
        height = 40,
        text = "SETTINGS",
        active = false,
    }
}

function titleScene:load(assets, actions, configs)
    self.assets       = assets
    self.actions      = actions
    self.configs      = configs

    -- Draw buttons with spacings
    local spacingY    = 8
    local totalHeight = #buttonOrder * buttons.start.height + (#buttonOrder - 1) * spacingY
    local startY      = (love.graphics.getHeight() - totalHeight) / 2 + 88

    for i = 1, #buttonOrder do
        local button = buttons[buttonOrder[i]]
        button.x = (love.graphics.getWidth() - button.width) / 2
        button.y = startY + (i - 1) * (button.height + spacingY)
    end

    self.cmsShader                  = moonshine(moonshine.effects.chromasep)
    self.cmsShader.chromasep.angle  = -math.pi / 4
    self.cmsShader.chromasep.radius = 4

    self.assets.titleSound:play()
end

-- Update active button only when the mouse moved
function titleScene:mousemoved(x, y, dx, dy, isTouch)
    local mx, my = love.mouse.getPosition()

    for i, name in ipairs(buttonOrder) do
        local btn = buttons[name]
        local isHovered =
            mx > btn.x and mx < btn.x + btn.width and
            my > btn.y and my < btn.y + btn.height

        btn.active = isHovered
        if isHovered then
            focusedIndex = i
        end
    end
end

function titleScene:mousepressed(x, y, btn, isTouch, presses)
    self.assets.clickSound:play()
    for _, b in pairs(buttons) do
        b.focused = false
    end

    if btn == 1 and buttons.start.active then
        buttons.start.active = true
        self.assets.titleSound:stop()
        self.actions.switchScene("main")
    elseif btn == 1 and buttons.lboard.active then
        buttons.lboard.active = true
        self.actions.switchScene("lboard")
    elseif btn == 1 and buttons.settings.active then
        buttons.settings.active = true
        self.actions.switchScene("settings")
    end
end

function titleScene:update(dt)
    if input:wasPressed("back") then self.actions.quit() end

    if input:wasPressed("accept") or input:wasPressed("jump") then
        if buttons.start.active then
            self.assets.titleSound:stop()
            self.actions.switchScene("main")
        elseif buttons.lboard.active then
            self.actions.switchScene("lboard")
        else
            self.actions.switchScene("settings")
        end
    end

    -- Update active button based on keyboard navigations
    if input:wasPressed("tab") or input:wasPressed("down") then
        for _, b in pairs(buttons) do b.active = false end
        focusedIndex = focusedIndex % #buttonOrder + 1
        buttons[buttonOrder[focusedIndex]].active = true
    elseif input:wasPressed("up") then
        for _, b in pairs(buttons) do b.active = false end
        focusedIndex = (focusedIndex - 2) % #buttonOrder + 1
        buttons[buttonOrder[focusedIndex]].active = true
    end
end

function titleScene:draw()
    local font = file:getFont(res.MAIN_FONT, consts.FONT_TITLE_SIZE)
    self.cmsShader(function()
        love.graphics.clear(colors.SLATE_100)
        drawer.drawCenteredText(consts.GAME_TITLE, font, 0, -68)
    end)

    font = file:getFont(res.MAIN_FONT, consts.FONT_SUB_SIZE)
    for _, b in pairs(buttons) do
        drawer.drawButton(b, font)
    end
end

return titleScene

================
File: src/utils/collider.lua
================
local collider = {}

function collider.aabb(a, b)
    return a.pos.x < b.pos.x + b.w and
        b.pos.x < a.pos.x + a.w and
        a.pos.y < b.pos.y + b.h and
        b.pos.y < a.pos.y + a.h
end

return collider

================
File: src/utils/drawer.lua
================
local colors = require("src.globals.colors")
local consts = require("src.globals.consts")
local res    = require("src.globals.res")
local file   = require("src.utils.file")

local drawer = {}

function drawer.drawCenteredText(text, font, xOffset, yOffset)
    local textW = font:getWidth(text)
    local textH = font:getHeight(text)
    local x = (love.graphics.getWidth() - textW) / 2 + xOffset
    local y = (love.graphics.getHeight() - textH) / 2 + yOffset

    love.graphics.print(text, x, y)
end

function drawer.drawButton(btn, font)
    -- Draw background
    if btn.active then
        -- Active button effect
        love.graphics.setColor(colors.SLATE_800)
        love.graphics.setLineWidth(2)
        love.graphics.rectangle("line", btn.x, btn.y, btn.width, btn.height, 4, 4)

        love.graphics.setColor(colors.SLATE_400)
    end

    -- Button text
    love.graphics.setColor(1, 1, 1)
    love.graphics.setFont(font)
    local textW = font:getWidth(btn.text)
    local textH = font:getHeight(btn.text)
    love.graphics.print(
        btn.text,
        btn.x + (btn.width - textW) / 2,
        btn.y + (btn.height - textH) / 2
    )
end

---Draw text overlays with background
---@param bgHeight number
---@param headerText string
---@param subTexts table
function drawer.drawOverlay(bgHeight, headerText, subTexts)
    love.graphics.setColor(colors.SLATE_800)
    local bgY = (love.graphics.getHeight() - bgHeight) / 2
    love.graphics.rectangle("fill", 0, bgY, love.graphics.getWidth(), bgHeight)

    local headerFont = file:getFont(res.MAIN_FONT, consts.FONT_HEADER_SIZE)
    love.graphics.setColor(colors.SLATE_100)
    drawer.drawCenteredText(headerText, headerFont, 0, subTexts[1].y - 18)

    local subFont = file:getFont(res.MAIN_FONT, consts.FONT_SUB_SIZE)
    love.graphics.setColor(colors.SLATE_300)
    for i, textInfo in ipairs(subTexts) do
        drawer.drawCenteredText(textInfo.text, subFont, 0, textInfo.y + 18 * i)
    end
end

return drawer

================
File: src/utils/file.lua
================
local res  = require("src.globals.res")

local file = { fontCache = {} }

-- Load font from provided path with fixed size <br/>
-- Also cache them and change to the new font
function file:getFont(path, size)
    self.fontCache[path] = self.fontCache[path] or {}

    self.fontCache[path][size] =
        self.fontCache[path][size] or
        love.graphics.newFont(path, size)

    local newFont = self.fontCache[path][size]
    love.graphics.setFont(newFont)

    return newFont
end

-- Save game configurations
function file.saveConfigs(configs)
    local lines = {}
    for k, v in pairs(configs) do
        table.insert(lines, k .. "=" .. tostring(v))
    end

    local content = table.concat(lines, "\n")
    love.filesystem.write(res.CONFIG_PATH, content)
end

-- Load game configurations
function file.loadConfigs()
    local configs = {}

    if love.filesystem.getInfo(res.CONFIG_PATH) then
        for line in love.filesystem.lines(res.CONFIG_PATH) do
            -- Split each config by the `=` sign
            local k, v = line:match("([^=]+)=([^=]+)")
            configs[k] = v
        end
    end

    return configs
end

-- Save only the five highest scores
function file.saveScores(scores)
    -- Sort and keep top 5
    table.sort(scores, function(a, b)
        return a > b
    end)

    -- Build the list to save
    local lines = {}
    for i = 1, math.min(5, #scores) do
        table.insert(lines, tostring(scores[i]))
    end

    local content = table.concat(lines, "\n")
    love.filesystem.write(res.SAVE_PATH, content)
end

-- Load previous highscores
function file.loadScores()
    local result = {}

    if love.filesystem.getInfo(res.SAVE_PATH) then
        for line in love.filesystem.lines(res.SAVE_PATH) do
            table.insert(result, tonumber(line))
        end
    end

    return result
end

return file

================
File: src/utils/input.lua
================
local input = {
    -- Action to keys mappings
    bindings = {
        up     = { "up", "w" },
        down   = { "down", "s" },
        left   = { "left", "a" },
        right  = { "right", "d" },
        accept = { "return" },
        back   = { "escape" },
        tab    = { "tab" },
        jump   = { "space" },
    },
    keysDown = {},     -- Currently held
    keysPressed = {},  -- Pressed this frame
    keysReleased = {}, -- Released this frame
}

function input:keypressed(key)
    self.keysDown[key] = true
    self.keysPressed[key] = true
end

function input:keyreleased(key)
    self.keysDown[key] = false
    self.keysReleased[key] = true
end

-- Check if an input action is currently held down
function input:isDown(action)
    local keys = self.bindings[action]
    if not keys then return false end

    for _, k in ipairs(keys) do
        if self.keysDown[k] then
            return true
        end
    end
    return false
end

-- Check if an input action was just pressed this frame
function input:wasPressed(action)
    local keys = self.bindings[action]
    if not keys then return false end

    for _, k in ipairs(keys) do
        if self.keysPressed[k] then
            return true
        end
    end
    return false
end

-- Check if an input action was released this frame
function input:wasReleased(action)
    local keys = self.bindings[action]
    if not keys then return false end

    for _, k in ipairs(keys) do
        if self.keysReleased[k] then return true end
    end
    return false
end

function input:update()
    -- Reset at the end of each frame
    self.keysPressed = {}
    self.keysReleased = {}
end

return input
